/* Generated By:JavaCC: Do not edit this line. ExpressionTokenManager.cc Version 8.0.0 */
/* ExpressionTokenManager.cc */
#include "ExpressionTokenManager.h"
#include "TokenMgrError.h"
#include "ExpressionTree.h"

static const long stringLiterals[] = {
1, 0, 32, 6, -1, 
1, 0, 40, 7, -1, 
1, 0, 9, 1, -1, 
1, 0, 41, 8, -1, 
2, 1, 105, 115, 73, 83, 21, -1, 
2, 1, 105, 115, 73, 83, 21, -1, 
1, 0, 10, 2, -1, 
1, 0, 11, 3, -1, 
1, 0, 12, 4, -1, 
1, 0, 44, 10, -1, 
1, 0, 13, 5, -1, 
1, 0, 46, 9, -1, 
4, 1, 110, 117, 108, 108, 78, 85, 76, 76, 19, -1, 
3, 1, 110, 111, 116, 78, 79, 84, 20, -1, 
4, 1, 110, 117, 108, 108, 78, 85, 76, 76, 19, -1, 
3, 1, 110, 111, 116, 78, 79, 84, 20, -1};

int ExpressionTokenManager::getStartAndSize(int index, int isCount)
{
  switch(index) {
    case 32: { return (isCount == 0) ? 0 : 1;}
    case 40: { return (isCount == 0) ? 5 : 1;}
    case 9: { return (isCount == 0) ? 10 : 1;}
    case 41: { return (isCount == 0) ? 15 : 1;}
    case 105: { return (isCount == 0) ? 20 : 1;}
    case 73: { return (isCount == 0) ? 28 : 1;}
    case 10: { return (isCount == 0) ? 36 : 1;}
    case 11: { return (isCount == 0) ? 41 : 1;}
    case 12: { return (isCount == 0) ? 46 : 1;}
    case 44: { return (isCount == 0) ? 51 : 1;}
    case 13: { return (isCount == 0) ? 56 : 1;}
    case 46: { return (isCount == 0) ? 61 : 1;}
    case 110: { return (isCount == 0) ? 66 : 2;}
    case 78: { return (isCount == 0) ? 88 : 2;}
  }
  return -1;
}

static const long jjCharData[][5] = {
{2, 1, 549755813888},
{2, 1, 549755813888},
{2, 1, 549755813888},
{4, 1, -549755813889, 1023, -1},
{2, 1, 549755813888},
{4, 1, 0, 1, 576460745995190270},
{4, 1, 287948901175001088, 1, 576460745995190270},
{2, 1, 17179869184},
{4, 1, -17179869185, 1023, -1},
{2, 1, 17179869184},
{4, 1, 0, 1, 16384},
{4, 1, 0, 1, 8589934592},
{4, 1, 0, 1, 16384},
{4, 1, 0, 1, 144115188075855872},
{4, 1, 0, 1, 4503599627370496},
{4, 1, 0, 1, 2199023255552},
{4, 1, 0, 1, 70368744177664},
{4, 1, 0, 1, 2199023255552},
{4, 1, 0, 1, 274877906944},
{4, 1, 0, 1, 70368744177664},
{4, 1, 0, 1, 512},
{2, 1, 70368744177664},
{2, 1, 287948901175001088},
{2, 1, 287948901175001088},
{2, 1, 281474976710656},
{2, 1, 70368744177664},
{2, 1, 70368744177664},
{2, 1, 287667426198290432},
{2, 1, 287948901175001088},
{2, 1, 287948901175001088},
{2, 1, 287948901175001088},
{2, 1, 287948901175001088}};

static const int jjcompositeState[][8] = {
{0, 5, 7, 12, 20, 21, 24, 27}, 
{}, 
{}, 
{}, 
{}, 
{}, 
{}, 
{}, 
{}, 
{}, 
{}, 
{}, 
{}, 
{}, 
{}, 
{}, 
{}, 
{}, 
{}, 
{}, 
{}, 
{}, 
{}, 
{}, 
{}, 
{}, 
{}, 
{}, 
{}, 
{}, 
{}, 
{}};

static const int jjmatchKinds[] = {
2147483647, 
2147483647, 
2147483647, 
2147483647, 
11, 
12, 
12, 
2147483647, 
2147483647, 
13, 
15, 
2147483647, 
2147483647, 
15, 
2147483647, 
2147483647, 
2147483647, 
2147483647, 
2147483647, 
2147483647, 
2147483647, 
2147483647, 
15, 
15, 
14, 
2147483647, 
2147483647, 
14, 
14, 
2147483647, 
2147483647, 
15};

static const int jjnextStateSet[][7] = {
{3, 2, 3, 4}, 
{3, 2, 3, 4}, 
{1, 1}, 
{3, 2, 3, 4}, 
{0}, 
{1, 6}, 
{1, 6}, 
{2, 8, 9}, 
{2, 8, 9}, 
{0}, 
{0}, 
{1, 10}, 
{1, 11}, 
{0}, 
{1, 13}, 
{1, 14}, 
{1, 15}, 
{1, 16}, 
{1, 17}, 
{1, 18}, 
{1, 19}, 
{2, 22, 23}, 
{1, 22}, 
{1, 23}, 
{2, 25, 26}, 
{1, 22}, 
{1, 23}, 
{6, 25, 26, 28, 29, 30, 31}, 
{1, 28}, 
{2, 25, 29}, 
{2, 26, 30}, 
{1, 31}};

static const int jjInitStates[]  = {
0};

static const int canMatchAnyChar[] = {
2147483647};

static const JJString jjstrLiteralImages[] = {
""
, 
"\11", 
"\12", 
"\13", 
"\14", 
"\15", 
"\40", 
"\50", 
"\51", 
"\56", 
"\54", 
""
, 
""
, 
""
, 
""
, 
""
, 
""
, 
""
, 
""
, 
"\156\165\154\154", 
"\116\117\124", 
"\111\123"};

static const long jjtoSkip[] = {
   8388734};
static const long jjtoSpecial[] = {
   8388608};
static const long jjtoMore[] = {
   8388608};
static const long jjtoToken[] = {
   12582785};
static const int jjnewLexState[] = {
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};

void ExpressionTokenManager::TokenLexicalActions(Token * matchedToken) {
  switch(matchedToken->kind) {
    default: break;
  }
}
void ExpressionTokenManager::SkipLexicalActions(Token * matchedToken) {
  switch(jjmatchedKind) {
    default: break;
  }
  switch(jjmatchedKind) {
    default: break;
  }
}
void ExpressionTokenManager::MoreLexicalActions() {
jjimageLen += (lengthOfMatch = jjmatchedPos + 1);
  switch(jjmatchedKind) {
    default: break;
  }
}
static const JJChar lexStateNames[] = {
"DEFAULT"};


bool ExpressionTokenManager::moveToNextChar() {
  if(input_stream->endOfInput())
    return false;

  curChar = input_stream->readChar();
  return true;
}



  /** Constructor. */
ExpressionTokenManager::ExpressionTokenManager (JAVACC_CHARSTREAM * stream, int lexState)
{
    ReInit(stream);
    if(lexState)
      SwitchTo(lexState);
}

  /** Reinitialise parser. */
 void ExpressionTokenManager::ReInit(JAVACC_CHARSTREAM * stream, int lexState)
{
    defaultLexState = 0;
    curLexState = 0;
    moveIndex = 1;
    errorHandler = nullptr;
    delete_eh = false;

    for (int i = 0; i < 32; i++) {
      int ind = 0;
      // We originally generate something like RLE for the static arrays and
      // we actually expannd them here.
      for (int j = 0; j < jjCharData[i][0]; j += 2) {
        for (int k = 0; k < (int)jjCharData[i][j + 1]; k++) {
          jjChars[i][ind++] = jjCharData[i][j + 2];
        }
      }
    }

    jjmatchedPos = 0;
    curLexState = defaultLexState;
    input_stream = stream;
    if(lexState)
      SwitchTo(lexState);
}

  /** Switch to specified lex state. */
void ExpressionTokenManager::SwitchTo(int lexState)
{
    curLexState = lexState;
}

 int ExpressionTokenManager::jjRunStringLiteralMatch() {
  int curPos = 0;
  int key = (int)curLexState << 16 | curChar;
  int startState = jjInitStates[curLexState];
  int index = getStartAndSize(key, 0);
  if (index != -1) {
    for (int i = 0; i < getStartAndSize(key, 1); i++) {
      int len = stringLiterals[index++];
      int ignoreCase = stringLiterals[index++];
      do {
        if (curChar != stringLiterals[index + curPos] &&
            (ignoreCase == 0 || curChar != stringLiterals[index + len + curPos])) break;
        if (++curPos == len) break;
        if (!moveToNextChar()) {
          --curPos;
          break;
        }
      } while(curPos < len);
      if (curPos == len) {
        jjmatchedKind = stringLiterals[index + len + (ignoreCase * len)];
        jjmatchedPos = curPos;
        startState = stringLiterals[index + len + (ignoreCase * len) + 1];
        if (!moveToNextChar()) {
          return curPos;
        }
        curPos++;
        break;
      } else {
        index += len + (ignoreCase * len) + 2;
        input_stream->backup(curPos + 1);
        curPos = 0;
        if (!moveToNextChar()) {
          assert(false);
        }
      }
    }
  } else {
  }
  return jjMoveNfa(startState, curPos);
}

 int ExpressionTokenManager::jjMoveNfa(int startState, int curPos) {

  if (startState < 0) {
    return curPos;
  }

  // We have a long array indexed by the NFA state number to roughly indicate
  // the input position so when the input reaches part 0x7fffffff (which
  // should be extremely rare), we need to reset them all back to zero.
  if (++moveIndex == 0x7fffffff) {
    for (int i = 0; i < 32; i++) moved[i] = 0L;
    moveIndex = 1ULL;
  }

  // We initialize the kind to MAX value so that when a match is found, we can
  // simply check if it's less than the current match and store it in that
  // case. This helps implement the 'first occurring' rule properly.
  int cnt = 0;
  stateSet[cnt++] = startState;
  moved[startState] = moveIndex;
 
  // Some NFA states have epsilon transitions (move on empty string). So we
  // just start with all of them. Note that the nextStates array already adds
  // the epsilon closure. Only the initial state needs to do this explicitly.
  for (int s : jjcompositeState[startState]) { 
    if (moved[s] != moveIndex) {
      stateSet[cnt++] = s;
      moved[s] = moveIndex;
    }
  }

  do {
    int newCnt = 0;
    int kind = 0x7fffffff;
    if (++moveIndex == 0x7fffffff) {
      for (int i = 0; i < 32; i++) moved[i] = 0L;
      moveIndex = 1ULL;
    }

    int vectorIndex = curChar >> 6;
    long bitpattern = (1ULL << (curChar & 0x37));
    do {
      int state = stateSet[--cnt];
      if ((jjChars[state][vectorIndex] & bitpattern) != 0L) {
        // Current input character can move this NFA state. So add all the
        // next states of the current states for use with the next input char.
        for (int idx = 0; idx < jjnextStateSet[state][0]; idx++) {
          int newState = jjnextStateSet[state][idx + 1];
          if (moved[newState] != moveIndex) {
            // We add each state only once.
            newStateSet[newCnt++] = newState;
            moved[newState] = moveIndex;
          }
        }
        int newKind = jjmatchKinds[state];
        if (kind > newKind) {
          // It's a state so store the matched kind if it's smaller than
          // what's already matched.
          kind = newKind;
        }
      }
    } while (cnt > 0);

    if (kind != 0x7fffffff) {
      // We found a match. So remember the kind and position of the match.
      jjmatchedKind = kind;
      jjmatchedPos = curPos;
      // Reset the kind to max value so we can contine looking for a longer
      // match.
      kind = 0x7fffffff;
    }

    // Swap the current and next state sets.
    int tmp;
    for(int i = 0; i < 32; i++) {
      tmp = stateSet[i];
      stateSet[i] = newStateSet[i];
      newStateSet[i] = tmp;
    }
    // Reset the number of states.
    cnt = newCnt;
    if (newCnt == 0) {
      // There were no transitions from any of the current states on the
      // current input. So we are done.
      return curPos;
    }
    // Read the next character and try to continue running the NFA.
    if (!moveToNextChar()) {
      // EOF reached!
      return curPos;
    }
    ++curPos;
  } while (cnt > 0);

  throw "Interal error. Please submit a bug at: http://javacc.java.net.";
//  return curPos;
}

static bool isToken(int kind) {
  return (jjtoToken[kind >> 6] & (1ULL << (kind & 077))) != 0L;
}

static bool isSkip(int kind) {
  return (jjtoSkip[kind >> 6] & (1ULL << (kind & 077))) != 0L;
}

static bool isSpecial(int kind) {
  return (jjtoSpecial[kind >> 6] & (1ULL << (kind & 077))) != 0L;
}

static bool isMore(int kind) {
  return (jjtoMore[kind >> 6] & (1ULL << (kind & 077))) != 0L;
}

 Token * ExpressionTokenManager::jjFillToken() {
  Token * t;
  JJString curTokenImage;
  int beginLine;
  int endLine;
  int beginColumn;
  int endColumn;
  if (jjmatchedPos < 0) {
    if (image.length() == 0) {
      curTokenImage = "";
    } else {
      curTokenImage = image;
    }
    beginLine = endLine = input_stream->getEndLine();
    beginColumn = endColumn = input_stream->getEndColumn();
  } else {
    JJString im = jjstrLiteralImages[jjmatchedKind];
    curTokenImage = (im.length() == 0) ? input_stream->GetImage() : im;
    beginLine = input_stream->getBeginLine();
    beginColumn = input_stream->getBeginColumn();
    endLine = input_stream->getEndLine();
    endColumn = input_stream->getEndColumn();
  }

   t = Token::newToken(jjmatchedKind);
   t->kind = jjmatchedKind;
   t->image = curTokenImage;

   t->beginLine = beginLine;
   t->endLine = endLine;
   t->beginColumn = beginColumn;
   t->endColumn = endColumn;

   return t;
}

/** Get the next Token. */
Token * ExpressionTokenManager::getNextToken() {
  Token * specialToken = nullptr;
  Token * matchedToken;
  int lastReadPosition = 0;

  EOFLoop:
  for (;;) {
    if(input_stream->endOfInput()) {
      // No input. So return EOF token.
      jjmatchedKind = _EOF;
      jjmatchedPos = -1;
      matchedToken = jjFillToken();
      matchedToken->specialToken = specialToken;
      return matchedToken;
    }

    // First see if we have any input at all.
    curChar = input_stream->BeginToken();


    // Set matched kind to a MAX VALUE to implement largest, first occuring rule
    // i.e., smallest kind value matched should be used.
    image = jjimage;
    // image->setLength(0);
    jjimageLen = 0;

    MoreLoop: for (;;) {
      jjmatchedKind = 0x7fffffff;
      jjmatchedPos = 0;
      lastReadPosition = jjRunStringLiteralMatch();
      if (jjmatchedPos == 0 && jjmatchedKind > canMatchAnyChar[curLexState]) {
        jjmatchedKind = canMatchAnyChar[curLexState];
      }

      if (jjmatchedKind != 0x7fffffff) {
        // We have a match!
  
        // Put back any characters looked ahead.
        input_stream->backup(lastReadPosition - jjmatchedPos);
        if (isToken(jjmatchedKind)) {
          // Matched kind is a real TOKEN.
          matchedToken = jjFillToken();
          matchedToken->specialToken = specialToken;
          TokenLexicalActions(matchedToken);
          if (jjnewLexState[jjmatchedKind] != -1) {
            curLexState = jjnewLexState[jjmatchedKind];
          }
          return matchedToken;
        } else if (isSkip(jjmatchedKind)) {
          // Matched kind is a SKIP or SPECIAL_TOKEN.
          if (isSpecial(jjmatchedKind)) {
            matchedToken = jjFillToken();
            if (specialToken == nullptr) {
              specialToken = matchedToken;
            } else {
              matchedToken->specialToken = specialToken;
              specialToken = (specialToken->next = matchedToken);
            }
            SkipLexicalActions(matchedToken);
          } else {
            SkipLexicalActions(nullptr);
          }
          if (jjnewLexState[jjmatchedKind] != -1) {
            curLexState = jjnewLexState[jjmatchedKind];
          }
          goto EOFLoop;
        }
        // Here it's a MORE.
        MoreLexicalActions();
        if (jjnewLexState[jjmatchedKind] != -1) {
          curLexState = jjnewLexState[jjmatchedKind];
        }
        lastReadPosition = 0;
        jjmatchedKind = 0x7fffffff;
        do {
          curChar = input_stream->readChar();
        } while(curChar >= 0);
      }
      reportError(lastReadPosition);
    }
  }
}

 void ExpressionTokenManager::reportError(int lastReadPosition) {
  int error_line = input_stream->getEndLine();
  int error_column = input_stream->getEndColumn();
  JJString error_after = "";
  bool EOFSeen = false;

  if(input_stream->readChar() < 0) {
    EOFSeen = true;
    error_after = lastReadPosition <= 1 ? "" : input_stream->GetImage();
    if (curChar == '\n' || curChar == '\r') {
       error_line++;
       error_column = 0;
    }
    else
       error_column++;
  } else {
    input_stream->backup(1);
  }
  if (!EOFSeen) {
    input_stream->backup(1);
    error_after = lastReadPosition <= 1 ? "" : input_stream->GetImage();
  }
  throw errorHandler->LexicalError(EOFSeen, curLexState, error_line, error_column, error_after, curChar);
}
/* JavaCC - OriginalChecksum=d79fce52c6298c96105aa51bd17f6776 (do not edit this line) */

/* Generated By:JavaCC: Do not edit this line. Expression.cc Version 8.0.0 */
#include "Expression.h"
#include "ExpressionTree.h"

#include "TokenMgrError.h"
  unsigned int jj_la1_0[] = {
0xe00000,0x1e00000,0x1e00000,0x1e00000,0xc0000000,0x0,0x1e00000,0x1000,0x80,0x1e00000,0x80,0x1000,0x80,0x1000,0x80,0x1000,0x80,0x1000,0x80,0x1000,0x80,0x80,0x0,0x0,0x800,0xa00,0xa00,0x1000,0x0,0x0,0x0,0x0,0xe9e86080,0xe9e00000,0x6000,0x0,0xe00000,0xe9f86080,0x0,0x0,0xe9f86080,0x100000,0xe9e86080,0x0,0x0,0x0,0x0,0x80000,0x0,0x0,0x30000000,0x0,0x0,0x1000,0xe9e06000,0x0,0x1000,0x1000,0x0,0x0,};
  unsigned int jj_la1_1[] = {
0x0,0x0,0x0,0xc000,0x7,0x1fe0,0xc000,0x0,0x0,0xc000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc000,0xc000,0x70000,0x70000,0xdff7,0xdff7,0x0,0x0,0x0,0x80dff7,0x200000,0x400000,0x80dff7,0x0,0xdff7,0x800000,0x7f000000,0x80800000,0x3f000000,0x800000,0x0,0x800000,0x0,0x800000,0x80800000,0x0,0xdff7,0x0,0x0,0x0,0x0,0x80000,};
  unsigned int jj_la1_2[] = {
0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x600000,0x1f0000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x600000,0x0,0x0,0x600000,0x600000,0x60fff0,0x0,0x0,0x60fff0,0xfff0,0x600000,0x4,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x8,0x0,0x0,0x0,0xfff0,0x0,0x0,0x600000,0x0,};

  /** Constructor with user supplied TokenManager. */




Node* Expression::compile() {
    compileExpression();
 return jjtree.rootNode();                           
assert(false);
}


void Expression::parseNull() {

    SimpleNode *jjtn001 = new SimpleNode(JJTNIL);
    bool jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    jjtreeOpenNodeScope(jjtn001);



                                 
  
    try {
      jj_consume_token(NULL_TOKEN);
    } catch (...) {      
        
        if (jjtc001) {
          jjtree.clearNodeScope(jjtn001);
          jjtc001 = false;
        } else {
          jjtree.popNode();
        }
    
    
    
    
    
         
      
    }

    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, true);
      if (jjtree.nodeCreated()) {
       jjtreeCloseNodeScope(jjtn001);
      }
    }





     
  
}


void Expression::parseBool() {

    SimpleNode *jjtn001 = new SimpleNode(JJTBOOL);
    bool jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    jjtreeOpenNodeScope(jjtn001);



                                 
  
    try {
      jj_consume_token(BOOL_TOKEN);
    } catch (...) {      
        
        if (jjtc001) {
          jjtree.clearNodeScope(jjtn001);
          jjtc001 = false;
        } else {
          jjtree.popNode();
        }
    
    
    
    
    
         
      
    }

    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, true);
      if (jjtree.nodeCreated()) {
       jjtreeCloseNodeScope(jjtn001);
      }
    }





     
  
}


void Expression::parseUuid() {

    SimpleNode *jjtn001 = new SimpleNode(JJTUUID);
    bool jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    jjtreeOpenNodeScope(jjtn001);



                                 
  
    try {
      jj_consume_token(UUID_TOKEN);
    } catch (...) {      
        
        if (jjtc001) {
          jjtree.clearNodeScope(jjtn001);
          jjtc001 = false;
        } else {
          jjtree.popNode();
        }
    
    
    
    
    
         
      
    }

    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, true);
      if (jjtree.nodeCreated()) {
       jjtreeCloseNodeScope(jjtn001);
      }
    }





     
  
}


void Expression::parseRegExp() {

    SimpleNode *jjtn001 = new SimpleNode(JJTREGEXP);
    bool jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    jjtreeOpenNodeScope(jjtn001);



                                 
  
    try {
      jj_consume_token(REGEXP_TOKEN);
    } catch (...) {      
        
        if (jjtc001) {
          jjtree.clearNodeScope(jjtn001);
          jjtc001 = false;
        } else {
          jjtree.popNode();
        }
    
    
    
    
    
         
      
    }

    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, true);
      if (jjtree.nodeCreated()) {
       jjtreeCloseNodeScope(jjtn001);
      }
    }





     
  
}


void Expression::parseString() {

    SimpleNode *jjtn001 = new SimpleNode(JJTSTRING);
    bool jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    jjtreeOpenNodeScope(jjtn001);



                                 
  
    try {
      jj_consume_token(STRING_TOKEN);
    } catch (...) {      
        
        if (jjtc001) {
          jjtree.clearNodeScope(jjtn001);
          jjtc001 = false;
        } else {
          jjtree.popNode();
        }
    
    
    
    
    
         
      
    }

    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, true);
      if (jjtree.nodeCreated()) {
       jjtreeCloseNodeScope(jjtn001);
      }
    }





     
  
}


void Expression::parseInteger() {
    switch (jj_nt->kind) {
    case OCTAL_TOKEN:{

    SimpleNode *jjtn001 = new SimpleNode(JJTOCTAL);
    bool jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    jjtreeOpenNodeScope(jjtn001);



                                 
  
      try {
        jj_consume_token(OCTAL_TOKEN);
      } catch (...) {      
          
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
      
      
      
      
      
           
        
      }

    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, true);
      if (jjtree.nodeCreated()) {
       jjtreeCloseNodeScope(jjtn001);
      }
    }





     
  
      break;
      }
    case INTEGER_TOKEN:{

    SimpleNode *jjtn002 = new SimpleNode(JJTINTEGER);
    bool jjtc002 = true;
    jjtree.openNodeScope(jjtn002);
    jjtreeOpenNodeScope(jjtn002);



                                 
  
      try {
        jj_consume_token(INTEGER_TOKEN);
      } catch (...) {      
          
          if (jjtc002) {
            jjtree.clearNodeScope(jjtn002);
            jjtc002 = false;
          } else {
            jjtree.popNode();
          }
      
      
      
      
      
           
        
      }

    if (jjtc002) {
      jjtree.closeNodeScope(jjtn002, true);
      if (jjtree.nodeCreated()) {
       jjtreeCloseNodeScope(jjtn002);
      }
    }





     
  
      break;
      }
    case HEXADECIMAL_TOKEN:{

    SimpleNode *jjtn003 = new SimpleNode(JJTHEXADECIMAL);
    bool jjtc003 = true;
    jjtree.openNodeScope(jjtn003);
    jjtreeOpenNodeScope(jjtn003);



                                 
  
      try {
        jj_consume_token(HEXADECIMAL_TOKEN);
      } catch (...) {      
          
          if (jjtc003) {
            jjtree.clearNodeScope(jjtn003);
            jjtc003 = false;
          } else {
            jjtree.popNode();
          }
      
      
      
      
      
           
        
      }

    if (jjtc003) {
      jjtree.closeNodeScope(jjtn003, true);
      if (jjtree.nodeCreated()) {
       jjtreeCloseNodeScope(jjtn003);
      }
    }





     
  
      break;
      }
    default:
      jj_la1[0] = jj_gen;
      jj_consume_token(-1);
      errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
    }
}


void Expression::parseDecimal() {

    SimpleNode *jjtn001 = new SimpleNode(JJTDECIMAL);
    bool jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    jjtreeOpenNodeScope(jjtn001);



                                 
  
    try {
      jj_consume_token(DECIMAL_TOKEN);
    } catch (...) {      
        
        if (jjtc001) {
          jjtree.clearNodeScope(jjtn001);
          jjtc001 = false;
        } else {
          jjtree.popNode();
        }
    
    
    
    
    
         
      
    }

    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, true);
      if (jjtree.nodeCreated()) {
       jjtreeCloseNodeScope(jjtn001);
      }
    }





     
  
}


void Expression::parseNumber() {
    switch (jj_nt->kind) {
    case OCTAL_TOKEN:
    case INTEGER_TOKEN:
    case HEXADECIMAL_TOKEN:{
      parseInteger();
      break;
      }
    case DECIMAL_TOKEN:{
      parseDecimal();
      break;
      }
    case ADD:{
      jj_consume_token(ADD);
      switch (jj_nt->kind) {
      case OCTAL_TOKEN:
      case INTEGER_TOKEN:
      case HEXADECIMAL_TOKEN:{
        parseInteger();
        break;
        }
      case DECIMAL_TOKEN:{
        parseDecimal();
        break;
        }
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
      }
      break;
      }
    case SUB:{
      jj_consume_token(SUB);
      switch (jj_nt->kind) {
      case OCTAL_TOKEN:
      case INTEGER_TOKEN:
      case HEXADECIMAL_TOKEN:{

             SimpleNode *jjtn001 = new SimpleNode(JJTNEGATIVE_INTEGER);
             bool jjtc001 = true;
             jjtree.openNodeScope(jjtn001);
             jjtreeOpenNodeScope(jjtn001);



                                          
           
        try {
          parseInteger();
        } catch (...) {      
                     
                     if (jjtc001) {
                       jjtree.clearNodeScope(jjtn001);
                       jjtc001 = false;
                     } else {
                       jjtree.popNode();
                     }
        
        
        
        
        
                      
                   
        }

             if (jjtc001) {
               jjtree.closeNodeScope(jjtn001, true);
               if (jjtree.nodeCreated()) {
                jjtreeCloseNodeScope(jjtn001);
               }
             }





              
           
        break;
        }
      case DECIMAL_TOKEN:{

                                                SimpleNode *jjtn002 = new SimpleNode(JJTNEGATIVE_NUMBER);
                                                bool jjtc002 = true;
                                                jjtree.openNodeScope(jjtn002);
                                                jjtreeOpenNodeScope(jjtn002);



                                                                             
                                              
        try {
          parseDecimal();
        } catch (...) {      
                                                        
                                                        if (jjtc002) {
                                                          jjtree.clearNodeScope(jjtn002);
                                                          jjtc002 = false;
                                                        } else {
                                                          jjtree.popNode();
                                                        }
        
        
        
        
        
                                                         
                                                      
        }

                                                if (jjtc002) {
                                                  jjtree.closeNodeScope(jjtn002, true);
                                                  if (jjtree.nodeCreated()) {
                                                   jjtreeCloseNodeScope(jjtn002);
                                                  }
                                                }





                                                 
                                              
        break;
        }
      default:
        jj_la1[2] = jj_gen;
        jj_consume_token(-1);
        errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
      }
      break;
      }
    default:
      jj_la1[3] = jj_gen;
      jj_consume_token(-1);
      errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
    }
}


void Expression::parseTemporal() {
    switch (jj_nt->kind) {
    case LOCALTIME_TOKEN:{

    SimpleNode *jjtn001 = new SimpleNode(JJTLOCALTIME);
    bool jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    jjtreeOpenNodeScope(jjtn001);



                                 
  
      try {
        jj_consume_token(LOCALTIME_TOKEN);
      } catch (...) {      
          
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
      
      
      
      
      
           
        
      }

    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, true);
      if (jjtree.nodeCreated()) {
       jjtreeCloseNodeScope(jjtn001);
      }
    }





     
  
      break;
      }
    case LOCALDATE_TOKEN:{

    SimpleNode *jjtn002 = new SimpleNode(JJTLOCALDATE);
    bool jjtc002 = true;
    jjtree.openNodeScope(jjtn002);
    jjtreeOpenNodeScope(jjtn002);



                                 
  
      try {
        jj_consume_token(LOCALDATE_TOKEN);
      } catch (...) {      
          
          if (jjtc002) {
            jjtree.clearNodeScope(jjtn002);
            jjtc002 = false;
          } else {
            jjtree.popNode();
          }
      
      
      
      
      
           
        
      }

    if (jjtc002) {
      jjtree.closeNodeScope(jjtn002, true);
      if (jjtree.nodeCreated()) {
       jjtreeCloseNodeScope(jjtn002);
      }
    }





     
  
      break;
      }
    case LOCALDATETIME_TOKEN:{

    SimpleNode *jjtn003 = new SimpleNode(JJTLOCALDATETIME);
    bool jjtc003 = true;
    jjtree.openNodeScope(jjtn003);
    jjtreeOpenNodeScope(jjtn003);



                                 
  
      try {
        jj_consume_token(LOCALDATETIME_TOKEN);
      } catch (...) {      
          
          if (jjtc003) {
            jjtree.clearNodeScope(jjtn003);
            jjtc003 = false;
          } else {
            jjtree.popNode();
          }
      
      
      
      
      
           
        
      }

    if (jjtc003) {
      jjtree.closeNodeScope(jjtn003, true);
      if (jjtree.nodeCreated()) {
       jjtreeCloseNodeScope(jjtn003);
      }
    }





     
  
      break;
      }
    case OFFSETTIME_TOKEN:{

    SimpleNode *jjtn004 = new SimpleNode(JJTOFFSETTIME);
    bool jjtc004 = true;
    jjtree.openNodeScope(jjtn004);
    jjtreeOpenNodeScope(jjtn004);



                                 
  
      try {
        jj_consume_token(OFFSETTIME_TOKEN);
      } catch (...) {      
          
          if (jjtc004) {
            jjtree.clearNodeScope(jjtn004);
            jjtc004 = false;
          } else {
            jjtree.popNode();
          }
      
      
      
      
      
           
        
      }

    if (jjtc004) {
      jjtree.closeNodeScope(jjtn004, true);
      if (jjtree.nodeCreated()) {
       jjtreeCloseNodeScope(jjtn004);
      }
    }





     
  
      break;
      }
    case OFFSETDATETIME_TOKEN:{

    SimpleNode *jjtn005 = new SimpleNode(JJTOFFSETDATETIME);
    bool jjtc005 = true;
    jjtree.openNodeScope(jjtn005);
    jjtreeOpenNodeScope(jjtn005);



                                 
  
      try {
        jj_consume_token(OFFSETDATETIME_TOKEN);
      } catch (...) {      
          
          if (jjtc005) {
            jjtree.clearNodeScope(jjtn005);
            jjtc005 = false;
          } else {
            jjtree.popNode();
          }
      
      
      
      
      
           
        
      }

    if (jjtc005) {
      jjtree.closeNodeScope(jjtn005, true);
      if (jjtree.nodeCreated()) {
       jjtreeCloseNodeScope(jjtn005);
      }
    }





     
  
      break;
      }
    default:
      jj_la1[4] = jj_gen;
      jj_consume_token(-1);
      errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
    }
}


void Expression::parseGeometry() {
    switch (jj_nt->kind) {
    case POINT_TOKEN:{
      jj_consume_token(POINT_TOKEN);
      parsePoint();
      break;
      }
    case POLYGON_TOKEN:{
      jj_consume_token(POLYGON_TOKEN);
      parsePolygon();
      break;
      }
    case LINESTRING_TOKEN:{
      jj_consume_token(LINESTRING_TOKEN);
      parseLineString();
      break;
      }
    case MULTIPOINT_TOKEN:{
      jj_consume_token(MULTIPOINT_TOKEN);
      parseMultiPoint();
      break;
      }
    case MULTIPOLYGON_TOKEN:{
      jj_consume_token(MULTIPOLYGON_TOKEN);
      parseMultiPolygon();
      break;
      }
    case MULTILINESTRING_TOKEN:{
      jj_consume_token(MULTILINESTRING_TOKEN);
      parseMultiLineString();
      break;
      }
    case GEOMETRYCOLLECTION_TOKEN:{
      jj_consume_token(GEOMETRYCOLLECTION_TOKEN);
      parseGeometryCollection();
      break;
      }
    case ENVELOPE_TOKEN:{
      jj_consume_token(ENVELOPE_TOKEN);
      parseEnvelope();
      break;
      }
    default:
      jj_la1[5] = jj_gen;
      jj_consume_token(-1);
      errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
    }
}


void Expression::parseEWKT() {/*@bgen(jjtree) EWKT */
  SimpleNode *jjtn000 = new SimpleNode(JJTEWKT);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);



                               
/*@egen*/

    try {
      jj_consume_token(SRID_TOKEN);
      parseNumber();
      jj_consume_token(SEMICOLON);
      parseGeometry();
    } catch (...) {      
        
        if (jjtc000) {
          jjtree.clearNodeScope(jjtn000);
          jjtc000 = false;
        } else {
          jjtree.popNode();
        }
    
    
    
    
    
         
      
    }

    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      if (jjtree.nodeCreated()) {
       jjtreeCloseNodeScope(jjtn000);
      }
    }





     
  
}


void Expression::parseCoordinate() {/*@bgen(jjtree) COORDINATE */
  SimpleNode *jjtn000 = new SimpleNode(JJTCOORDINATE);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);



                               
/*@egen*/

    try {
      parseNumber();
      while (!hasError) {
        parseNumber();
        switch (jj_nt->kind) {
        case OCTAL_TOKEN:
        case INTEGER_TOKEN:
        case HEXADECIMAL_TOKEN:
        case DECIMAL_TOKEN:
        case ADD:
        case SUB:{
          ;
          break;
          }
        default:
          jj_la1[6] = jj_gen;
          goto end_label_1;
        }
      }
      end_label_1: ;
    } catch (...) {      
        
        if (jjtc000) {
          jjtree.clearNodeScope(jjtn000);
          jjtc000 = false;
        } else {
          jjtree.popNode();
        }
    
    
    
    
    
         
      
    }

    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      if (jjtree.nodeCreated()) {
       jjtreeCloseNodeScope(jjtn000);
      }
    }





     
  
}


void Expression::parseCoordinateArray() {/*@bgen(jjtree) COORDINATEARRAY */
  SimpleNode *jjtn000 = new SimpleNode(JJTCOORDINATEARRAY);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);



                               
/*@egen*/

    try {
      jj_consume_token(LP);
      parseCoordinate();
      while (!hasError) {
        switch (jj_nt->kind) {
        case COMMA:{
          ;
          break;
          }
        default:
          jj_la1[7] = jj_gen;
          goto end_label_2;
        }
        jj_consume_token(COMMA);
        parseCoordinate();
      }
      end_label_2: ;
      jj_consume_token(RP);
    } catch (...) {      
        
        if (jjtc000) {
          jjtree.clearNodeScope(jjtn000);
          jjtc000 = false;
        } else {
          jjtree.popNode();
        }
    
    
    
    
    
         
      
    }

    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      if (jjtree.nodeCreated()) {
       jjtreeCloseNodeScope(jjtn000);
      }
    }





     
  
}


void Expression::parsePoint() {/*@bgen(jjtree) POINT */
  SimpleNode *jjtn000 = new SimpleNode(JJTPOINT);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);



                               
/*@egen*/

    try {
      switch (jj_nt->kind) {
      case LP:{
        jj_consume_token(LP);
        parseCoordinate();
        jj_consume_token(RP);
        break;
        }
      default:
        jj_la1[8] = jj_gen;
        ;
      }
    } catch (...) {      
        
        if (jjtc000) {
          jjtree.clearNodeScope(jjtn000);
          jjtc000 = false;
        } else {
          jjtree.popNode();
        }
    
    
    
    
    
         
      
    }

    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      if (jjtree.nodeCreated()) {
       jjtreeCloseNodeScope(jjtn000);
      }
    }





     
  
}


void Expression::parsePointCoordinate() {
    switch (jj_nt->kind) {
    case OCTAL_TOKEN:
    case INTEGER_TOKEN:
    case HEXADECIMAL_TOKEN:
    case DECIMAL_TOKEN:
    case ADD:
    case SUB:{

    SimpleNode *jjtn001 = new SimpleNode(JJTPOINT);
    bool jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    jjtreeOpenNodeScope(jjtn001);



                                 
  
      try {
        parseCoordinate();
      } catch (...) {      
          
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
      
      
      
      
      
           
        
      }

    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, true);
      if (jjtree.nodeCreated()) {
       jjtreeCloseNodeScope(jjtn001);
      }
    }





     
  
      break;
      }
    default:
      jj_la1[9] = jj_gen;
      parsePoint();
    }
}


void Expression::parseLineString() {/*@bgen(jjtree) LINESTRING */
  SimpleNode *jjtn000 = new SimpleNode(JJTLINESTRING);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);



                               
/*@egen*/

    try {
      switch (jj_nt->kind) {
      case LP:{
        parseCoordinateArray();
        break;
        }
      default:
        jj_la1[10] = jj_gen;
        ;
      }
    } catch (...) {      
        
        if (jjtc000) {
          jjtree.clearNodeScope(jjtn000);
          jjtc000 = false;
        } else {
          jjtree.popNode();
        }
    
    
    
    
    
         
      
    }

    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      if (jjtree.nodeCreated()) {
       jjtreeCloseNodeScope(jjtn000);
      }
    }





     
  
}


void Expression::parsePolygon() {/*@bgen(jjtree) POLYGON */
  SimpleNode *jjtn000 = new SimpleNode(JJTPOLYGON);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);



                               
/*@egen*/

    try {
      switch (jj_nt->kind) {
      case LP:{
        jj_consume_token(LP);
        parseCoordinateArray();
        while (!hasError) {
          switch (jj_nt->kind) {
          case COMMA:{
            ;
            break;
            }
          default:
            jj_la1[11] = jj_gen;
            goto end_label_3;
          }
          jj_consume_token(COMMA);
          parseCoordinateArray();
        }
        end_label_3: ;
        jj_consume_token(RP);
        break;
        }
      default:
        jj_la1[12] = jj_gen;
        ;
      }
    } catch (...) {      
        
        if (jjtc000) {
          jjtree.clearNodeScope(jjtn000);
          jjtc000 = false;
        } else {
          jjtree.popNode();
        }
    
    
    
    
    
         
      
    }

    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      if (jjtree.nodeCreated()) {
       jjtreeCloseNodeScope(jjtn000);
      }
    }





     
  
}


void Expression::parseMultiPoint() {/*@bgen(jjtree) MULTIPOINT */
  SimpleNode *jjtn000 = new SimpleNode(JJTMULTIPOINT);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);



                               
/*@egen*/

    try {
      switch (jj_nt->kind) {
      case LP:{
        jj_consume_token(LP);
        parsePointCoordinate();
        while (!hasError) {
          switch (jj_nt->kind) {
          case COMMA:{
            ;
            break;
            }
          default:
            jj_la1[13] = jj_gen;
            goto end_label_4;
          }
          jj_consume_token(COMMA);
          parsePointCoordinate();
        }
        end_label_4: ;
        jj_consume_token(RP);
        break;
        }
      default:
        jj_la1[14] = jj_gen;
        ;
      }
    } catch (...) {      
        
        if (jjtc000) {
          jjtree.clearNodeScope(jjtn000);
          jjtc000 = false;
        } else {
          jjtree.popNode();
        }
    
    
    
    
    
         
      
    }

    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      if (jjtree.nodeCreated()) {
       jjtreeCloseNodeScope(jjtn000);
      }
    }





     
  
}


void Expression::parseMultiLineString() {/*@bgen(jjtree) MULTILINESTRING */
  SimpleNode *jjtn000 = new SimpleNode(JJTMULTILINESTRING);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);



                               
/*@egen*/

    try {
      switch (jj_nt->kind) {
      case LP:{
        jj_consume_token(LP);
        parseLineString();
        while (!hasError) {
          switch (jj_nt->kind) {
          case COMMA:{
            ;
            break;
            }
          default:
            jj_la1[15] = jj_gen;
            goto end_label_5;
          }
          jj_consume_token(COMMA);
          parseLineString();
        }
        end_label_5: ;
        jj_consume_token(RP);
        break;
        }
      default:
        jj_la1[16] = jj_gen;
        ;
      }
    } catch (...) {      
        
        if (jjtc000) {
          jjtree.clearNodeScope(jjtn000);
          jjtc000 = false;
        } else {
          jjtree.popNode();
        }
    
    
    
    
    
         
      
    }

    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      if (jjtree.nodeCreated()) {
       jjtreeCloseNodeScope(jjtn000);
      }
    }





     
  
}


void Expression::parseMultiPolygon() {/*@bgen(jjtree) MULTIPOLYGON */
  SimpleNode *jjtn000 = new SimpleNode(JJTMULTIPOLYGON);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);



                               
/*@egen*/

    try {
      switch (jj_nt->kind) {
      case LP:{
        jj_consume_token(LP);
        parsePolygon();
        while (!hasError) {
          switch (jj_nt->kind) {
          case COMMA:{
            ;
            break;
            }
          default:
            jj_la1[17] = jj_gen;
            goto end_label_6;
          }
          jj_consume_token(COMMA);
          parsePolygon();
        }
        end_label_6: ;
        jj_consume_token(RP);
        break;
        }
      default:
        jj_la1[18] = jj_gen;
        ;
      }
    } catch (...) {      
        
        if (jjtc000) {
          jjtree.clearNodeScope(jjtn000);
          jjtc000 = false;
        } else {
          jjtree.popNode();
        }
    
    
    
    
    
         
      
    }

    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      if (jjtree.nodeCreated()) {
       jjtreeCloseNodeScope(jjtn000);
      }
    }





     
  
}


void Expression::parseGeometryCollection() {/*@bgen(jjtree) GEOMETRYCOLLECTION */
  SimpleNode *jjtn000 = new SimpleNode(JJTGEOMETRYCOLLECTION);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);



                               
/*@egen*/

    try {
      switch (jj_nt->kind) {
      case LP:{
        jj_consume_token(LP);
        parseGeometry();
        while (!hasError) {
          switch (jj_nt->kind) {
          case COMMA:{
            ;
            break;
            }
          default:
            jj_la1[19] = jj_gen;
            goto end_label_7;
          }
          jj_consume_token(COMMA);
          parseGeometry();
        }
        end_label_7: ;
        jj_consume_token(RP);
        break;
        }
      default:
        jj_la1[20] = jj_gen;
        ;
      }
    } catch (...) {      
        
        if (jjtc000) {
          jjtree.clearNodeScope(jjtn000);
          jjtc000 = false;
        } else {
          jjtree.popNode();
        }
    
    
    
    
    
         
      
    }

    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      if (jjtree.nodeCreated()) {
       jjtreeCloseNodeScope(jjtn000);
      }
    }





     
  
}


void Expression::parseEnvelope() {/*@bgen(jjtree) ENVELOPE */
  SimpleNode *jjtn000 = new SimpleNode(JJTENVELOPE);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);



                               
/*@egen*/

    try {
      switch (jj_nt->kind) {
      case LP:{
        jj_consume_token(LP);
        parseNumber();
        jj_consume_token(COMMA);
        parseNumber();
        jj_consume_token(COMMA);
        parseNumber();
        jj_consume_token(COMMA);
        parseNumber();
        jj_consume_token(RP);
        break;
        }
      default:
        jj_la1[21] = jj_gen;
        ;
      }
    } catch (...) {      
        
        if (jjtc000) {
          jjtree.clearNodeScope(jjtn000);
          jjtc000 = false;
        } else {
          jjtree.popNode();
        }
    
    
    
    
    
         
      
    }

    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      if (jjtree.nodeCreated()) {
       jjtreeCloseNodeScope(jjtn000);
      }
    }





     
  
}


void Expression::parseIdentifier() {
    switch (jj_nt->kind) {
    case IDENTIFIER_TOKEN:{

    SimpleNode *jjtn001 = new SimpleNode(JJTIDENTIFIER);
    bool jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    jjtreeOpenNodeScope(jjtn001);



                                 
  
      try {
        jj_consume_token(IDENTIFIER_TOKEN);
      } catch (...) {      
          
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
      
      
      
      
      
           
        
      }

    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, true);
      if (jjtree.nodeCreated()) {
       jjtreeCloseNodeScope(jjtn001);
      }
    }





     
  
      break;
      }
    case IDENTIFIER_QUOTED_TOKEN:{

    SimpleNode *jjtn002 = new SimpleNode(JJTIDENTIFIER_QUOTED);
    bool jjtc002 = true;
    jjtree.openNodeScope(jjtn002);
    jjtreeOpenNodeScope(jjtn002);



                                 
  
      try {
        jj_consume_token(IDENTIFIER_QUOTED_TOKEN);
      } catch (...) {      
          
          if (jjtc002) {
            jjtree.clearNodeScope(jjtn002);
            jjtc002 = false;
          } else {
            jjtree.popNode();
          }
      
      
      
      
      
           
        
      }

    if (jjtc002) {
      jjtree.closeNodeScope(jjtn002, true);
      if (jjtree.nodeCreated()) {
       jjtreeCloseNodeScope(jjtn002);
      }
    }





     
  
      break;
      }
    default:
      jj_la1[22] = jj_gen;
      jj_consume_token(-1);
      errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
    }
}


void Expression::parseDE9IM() {

    SimpleNode *jjtn001 = new SimpleNode(JJTDE9IM);
    bool jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    jjtreeOpenNodeScope(jjtn001);



                                 
  
    try {
      jj_consume_token(DE9IM);
    } catch (...) {      
        
        if (jjtc001) {
          jjtree.clearNodeScope(jjtn001);
          jjtc001 = false;
        } else {
          jjtree.popNode();
        }
    
    
    
    
    
         
      
    }

    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, true);
      if (jjtree.nodeCreated()) {
       jjtreeCloseNodeScope(jjtn001);
      }
    }





     
  
}


void Expression::parseDistanceUnits() {/*@bgen(jjtree) LENGTH_UNITS */
  SimpleNode *jjtn000 = new SimpleNode(JJTLENGTH_UNITS);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);



                               
/*@egen*/

    try {
      switch (jj_nt->kind) {
      case FEET:{
        jj_consume_token(FEET);
        break;
        }
      case METERS:{
        jj_consume_token(METERS);
        break;
        }
      case KILOMETERS:{
        jj_consume_token(KILOMETERS);
        break;
        }
      case STATUTE_MILES:{
        jj_consume_token(STATUTE_MILES);
        break;
        }
      case NAUTICAL_MILES:{
        jj_consume_token(NAUTICAL_MILES);
        break;
        }
      default:
        jj_la1[23] = jj_gen;
        jj_consume_token(-1);
        errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
      }
    } catch (...) {      
        
        if (jjtc000) {
          jjtree.clearNodeScope(jjtn000);
          jjtc000 = false;
        } else {
          jjtree.popNode();
        }
    
    
    
    
    
         
      
    }

    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      if (jjtree.nodeCreated()) {
       jjtreeCloseNodeScope(jjtn000);
      }
    }





     
  
}


void Expression::compileName() {
    parseName();
    jj_consume_token(0);
}


void Expression::parseName() {/*@bgen(jjtree) NAME */
  SimpleNode *jjtn000 = new SimpleNode(JJTNAME);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);



                               
/*@egen*/

    try {
      parseLocalName();
      switch (jj_nt->kind) {
      case LSP:
      case DOT:{
        switch (jj_nt->kind) {
        case DOT:{
          jj_consume_token(DOT);
          parseName();
          break;
          }
        case LSP:{
          jj_consume_token(LSP);

              SimpleNode *jjtn001 = new SimpleNode(JJTCLASSIFIER);
              bool jjtc001 = true;
              jjtree.openNodeScope(jjtn001);
              jjtreeOpenNodeScope(jjtn001);



                                           
            
          try {
            parseIdentifier();
          } catch (...) {      
                        
                        if (jjtc001) {
                          jjtree.clearNodeScope(jjtn001);
                          jjtc001 = false;
                        } else {
                          jjtree.popNode();
                        }
          
          
          
          
          
                         
                      
          }

              if (jjtc001) {
                jjtree.closeNodeScope(jjtn001, true);
                if (jjtree.nodeCreated()) {
                 jjtreeCloseNodeScope(jjtn001);
                }
              }





               
            
          jj_consume_token(RSP);
          switch (jj_nt->kind) {
          case DOT:{
            jj_consume_token(DOT);
            parseName();
            break;
            }
          default:
            jj_la1[24] = jj_gen;
            ;
          }
          break;
          }
        default:
          jj_la1[25] = jj_gen;
          jj_consume_token(-1);
          errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
        }
        break;
        }
      default:
        jj_la1[26] = jj_gen;
        ;
      }
    } catch (...) {      
        
        if (jjtc000) {
          jjtree.clearNodeScope(jjtn000);
          jjtc000 = false;
        } else {
          jjtree.popNode();
        }
    
    
    
    
    
         
      
    }

    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      if (jjtree.nodeCreated()) {
       jjtreeCloseNodeScope(jjtn000);
      }
    }





     
  
}


void Expression::parseLocalName() {/*@bgen(jjtree) LOCALNAME */
  SimpleNode *jjtn000 = new SimpleNode(JJTLOCALNAME);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);



                               
/*@egen*/

    try {
      parseIdentifier();
    } catch (...) {      
        
        if (jjtc000) {
          jjtree.clearNodeScope(jjtn000);
          jjtc000 = false;
        } else {
          jjtree.popNode();
        }
    
    
    
    
    
         
      
    }

    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      if (jjtree.nodeCreated()) {
       jjtreeCloseNodeScope(jjtn000);
      }
    }





     
  
}


void Expression::compileExpression() {
    parseExpressionList();
    jj_consume_token(0);
}


void Expression::parseExpressionList() {/*@bgen(jjtree) EXPRESSIONLIST */
  SimpleNode *jjtn000 = new SimpleNode(JJTEXPRESSIONLIST);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);



                               
/*@egen*/

    try {
      parseFilter();
      while (!hasError) {
        switch (jj_nt->kind) {
        case COMMA:{
          ;
          break;
          }
        default:
          jj_la1[27] = jj_gen;
          goto end_label_8;
        }
        jj_consume_token(COMMA);
        parseFilter();
      }
      end_label_8: ;
    } catch (...) {      
        
        if (jjtc000) {
          jjtree.clearNodeScope(jjtn000);
          jjtc000 = false;
        } else {
          jjtree.popNode();
        }
    
    
    
    
    
         
      
    }

    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      if (jjtree.nodeCreated()) {
       jjtreeCloseNodeScope(jjtn000);
      }
    }





     
  
}


void Expression::parseExpression() {/*@bgen(jjtree) BINARYEXPRESSION */
  SimpleNode *jjtn000 = new SimpleNode(JJTBINARYEXPRESSION);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);



                               
/*@egen*/

    try {
      parseMultiplicativeExpression();
      while (!hasError) {
        switch (jj_nt->kind) {
        case ADD:
        case SUB:{
          ;
          break;
          }
        default:
          jj_la1[28] = jj_gen;
          goto end_label_9;
        }
        switch (jj_nt->kind) {
        case ADD:{
          jj_consume_token(ADD);

              SimpleNode *jjtn001 = new SimpleNode(JJTADDITION);
              bool jjtc001 = true;
              jjtree.openNodeScope(jjtn001);
              jjtreeOpenNodeScope(jjtn001);



                                           
            
          try {
            parseMultiplicativeExpression();
          } catch (...) {      
                        
                        if (jjtc001) {
                          jjtree.clearNodeScope(jjtn001);
                          jjtc001 = false;
                        } else {
                          jjtree.popNode();
                        }
          
          
          
          
          
                         
                      
          }

              if (jjtc001) {
                jjtree.closeNodeScope(jjtn001, true);
                if (jjtree.nodeCreated()) {
                 jjtreeCloseNodeScope(jjtn001);
                }
              }





               
            
          break;
          }
        case SUB:{
          jj_consume_token(SUB);

              SimpleNode *jjtn002 = new SimpleNode(JJTSUBTRACTION);
              bool jjtc002 = true;
              jjtree.openNodeScope(jjtn002);
              jjtreeOpenNodeScope(jjtn002);



                                           
            
          try {
            parseMultiplicativeExpression();
          } catch (...) {      
                        
                        if (jjtc002) {
                          jjtree.clearNodeScope(jjtn002);
                          jjtc002 = false;
                        } else {
                          jjtree.popNode();
                        }
          
          
          
          
          
                         
                      
          }

              if (jjtc002) {
                jjtree.closeNodeScope(jjtn002, true);
                if (jjtree.nodeCreated()) {
                 jjtreeCloseNodeScope(jjtn002);
                }
              }





               
            
          break;
          }
        default:
          jj_la1[29] = jj_gen;
          jj_consume_token(-1);
          errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
        }
      }
      end_label_9: ;
    } catch (...) {      
        
        if (jjtc000) {
          jjtree.clearNodeScope(jjtn000);
          jjtc000 = false;
        } else {
          jjtree.popNode();
        }
    
    
    
    
    
         
      
    }

    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      if (jjtree.nodeCreated()) {
       jjtreeCloseNodeScope(jjtn000);
      }
    }





     
  
}


void Expression::parseMultiplicativeExpression() {/*@bgen(jjtree) BinaryExpression */
  SimpleNode *jjtn000 = new SimpleNode(JJTBINARYEXPRESSION);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);



                               
/*@egen*/

    try {
      parseUnaryExpression();
      while (!hasError) {
        switch (jj_nt->kind) {
        case MUL:
        case DIV:
        case MOD:{
          ;
          break;
          }
        default:
          jj_la1[30] = jj_gen;
          goto end_label_10;
        }
        switch (jj_nt->kind) {
        case MUL:{
          jj_consume_token(MUL);

              SimpleNode *jjtn001 = new SimpleNode(JJTMULTIPLICATION);
              bool jjtc001 = true;
              jjtree.openNodeScope(jjtn001);
              jjtreeOpenNodeScope(jjtn001);



                                           
            
          try {
            parseUnaryExpression();
          } catch (...) {      
                        
                        if (jjtc001) {
                          jjtree.clearNodeScope(jjtn001);
                          jjtc001 = false;
                        } else {
                          jjtree.popNode();
                        }
          
          
          
          
          
                         
                      
          }

              if (jjtc001) {
                jjtree.closeNodeScope(jjtn001, true);
                if (jjtree.nodeCreated()) {
                 jjtreeCloseNodeScope(jjtn001);
                }
              }





               
            
          break;
          }
        case DIV:{
          jj_consume_token(DIV);

              SimpleNode *jjtn002 = new SimpleNode(JJTDIVISION);
              bool jjtc002 = true;
              jjtree.openNodeScope(jjtn002);
              jjtreeOpenNodeScope(jjtn002);



                                           
            
          try {
            parseUnaryExpression();
          } catch (...) {      
                        
                        if (jjtc002) {
                          jjtree.clearNodeScope(jjtn002);
                          jjtc002 = false;
                        } else {
                          jjtree.popNode();
                        }
          
          
          
          
          
                         
                      
          }

              if (jjtc002) {
                jjtree.closeNodeScope(jjtn002, true);
                if (jjtree.nodeCreated()) {
                 jjtreeCloseNodeScope(jjtn002);
                }
              }





               
            
          break;
          }
        case MOD:{
          jj_consume_token(MOD);

              SimpleNode *jjtn003 = new SimpleNode(JJTMODULO);
              bool jjtc003 = true;
              jjtree.openNodeScope(jjtn003);
              jjtreeOpenNodeScope(jjtn003);



                                           
            
          try {
            parseUnaryExpression();
          } catch (...) {      
                        
                        if (jjtc003) {
                          jjtree.clearNodeScope(jjtn003);
                          jjtc003 = false;
                        } else {
                          jjtree.popNode();
                        }
          
          
          
          
          
                         
                      
          }

              if (jjtc003) {
                jjtree.closeNodeScope(jjtn003, true);
                if (jjtree.nodeCreated()) {
                 jjtreeCloseNodeScope(jjtn003);
                }
              }





               
            
          break;
          }
        default:
          jj_la1[31] = jj_gen;
          jj_consume_token(-1);
          errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
        }
      }
      end_label_10: ;
    } catch (...) {      
        
        if (jjtc000) {
          jjtree.clearNodeScope(jjtn000);
          jjtc000 = false;
        } else {
          jjtree.popNode();
        }
    
    
    
    
    
         
      
    }

    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      if (jjtree.nodeCreated()) {
       jjtreeCloseNodeScope(jjtn000);
      }
    }





     
  
}


void Expression::parseUnaryExpression() {
    switch (jj_nt->kind) {
    case NULL_TOKEN:{
      parseNull();
      break;
      }
    case OCTAL_TOKEN:
    case INTEGER_TOKEN:
    case HEXADECIMAL_TOKEN:
    case DECIMAL_TOKEN:
    case UUID_TOKEN:
    case STRING_TOKEN:
    case LOCALTIME_TOKEN:
    case LOCALDATE_TOKEN:
    case LOCALDATETIME_TOKEN:
    case OFFSETTIME_TOKEN:
    case OFFSETDATETIME_TOKEN:
    case SRID_TOKEN:
    case POINT_TOKEN:
    case POLYGON_TOKEN:
    case LINESTRING_TOKEN:
    case MULTIPOINT_TOKEN:
    case MULTIPOLYGON_TOKEN:
    case MULTILINESTRING_TOKEN:
    case GEOMETRYCOLLECTION_TOKEN:
    case ENVELOPE_TOKEN:
    case ADD:
    case SUB:{
      parseLiteral();
      break;
      }
    case COLON:
    case DOLLAR:
    case IDENTIFIER_TOKEN:
    case IDENTIFIER_QUOTED_TOKEN:{
      parseNamedExpression();
      break;
      }
    case LP:{
      jj_consume_token(LP);
      parseFilter();
      jj_consume_token(RP);
      break;
      }
    default:
      jj_la1[32] = jj_gen;
      jj_consume_token(-1);
      errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
    }
}


void Expression::parseLiteral() {/*@bgen(jjtree) LITERAL */
  SimpleNode *jjtn000 = new SimpleNode(JJTLITERAL);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);



                               
/*@egen*/

    try {
      switch (jj_nt->kind) {
      case UUID_TOKEN:{
        parseUuid();
        break;
        }
      case OCTAL_TOKEN:
      case INTEGER_TOKEN:
      case HEXADECIMAL_TOKEN:
      case DECIMAL_TOKEN:
      case ADD:
      case SUB:{
        parseNumber();
        break;
        }
      case STRING_TOKEN:{
        parseString();
        break;
        }
      case LOCALTIME_TOKEN:
      case LOCALDATE_TOKEN:
      case LOCALDATETIME_TOKEN:
      case OFFSETTIME_TOKEN:
      case OFFSETDATETIME_TOKEN:{
        parseTemporal();
        break;
        }
      case POINT_TOKEN:
      case POLYGON_TOKEN:
      case LINESTRING_TOKEN:
      case MULTIPOINT_TOKEN:
      case MULTIPOLYGON_TOKEN:
      case MULTILINESTRING_TOKEN:
      case GEOMETRYCOLLECTION_TOKEN:
      case ENVELOPE_TOKEN:{
        parseGeometry();
        break;
        }
      case SRID_TOKEN:{
        parseEWKT();
        break;
        }
      default:
        jj_la1[33] = jj_gen;
        jj_consume_token(-1);
        errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
      }
    } catch (...) {      
        
        if (jjtc000) {
          jjtree.clearNodeScope(jjtn000);
          jjtc000 = false;
        } else {
          jjtree.popNode();
        }
    
    
    
    
    
         
      
    }

    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      if (jjtree.nodeCreated()) {
       jjtreeCloseNodeScope(jjtn000);
      }
    }





     
  
}


void Expression::parseNamedExpression() {
    switch (jj_nt->kind) {
    case COLON:{
      parseBinding();
      break;
      }
    case DOLLAR:{
      parseParameter();
      break;
      }
    default:
      jj_la1[34] = jj_gen;
      if (jj_2_1(2147483647)) {
        parseFunction();
      } else {
        switch (jj_nt->kind) {
        case IDENTIFIER_TOKEN:
        case IDENTIFIER_QUOTED_TOKEN:{
          parseAttribute();
          break;
          }
        default:
          jj_la1[35] = jj_gen;
          jj_consume_token(-1);
          errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
        }
      }
    }
}


void Expression::parseParameter() {
    jj_consume_token(DOLLAR);
    switch (jj_nt->kind) {
    case IDENTIFIER_TOKEN:
    case IDENTIFIER_QUOTED_TOKEN:{

      SimpleNode *jjtn001 = new SimpleNode(JJTPARAMETER);
      bool jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);



                                   
    
      try {
        parseIdentifier();
      } catch (...) {      
            
            if (jjtc001) {
              jjtree.clearNodeScope(jjtn001);
              jjtc001 = false;
            } else {
              jjtree.popNode();
            }
      
      
      
      
      
             
          
      }

      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, true);
        if (jjtree.nodeCreated()) {
         jjtreeCloseNodeScope(jjtn001);
        }
      }





       
    
      break;
      }
    case OCTAL_TOKEN:
    case INTEGER_TOKEN:
    case HEXADECIMAL_TOKEN:{

      SimpleNode *jjtn002 = new SimpleNode(JJTPARAMETERINDEX);
      bool jjtc002 = true;
      jjtree.openNodeScope(jjtn002);
      jjtreeOpenNodeScope(jjtn002);



                                   
    
      try {
        parseInteger();
      } catch (...) {      
            
            if (jjtc002) {
              jjtree.clearNodeScope(jjtn002);
              jjtc002 = false;
            } else {
              jjtree.popNode();
            }
      
      
      
      
      
             
          
      }

      if (jjtc002) {
        jjtree.closeNodeScope(jjtn002, true);
        if (jjtree.nodeCreated()) {
         jjtreeCloseNodeScope(jjtn002);
        }
      }





       
    
      break;
      }
    default:
      jj_la1[36] = jj_gen;
      jj_consume_token(-1);
      errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
    }
}


void Expression::parseBinding() {/*@bgen(jjtree) BINDING */
  SimpleNode *jjtn000 = new SimpleNode(JJTBINDING);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);



                               
/*@egen*/

    try {
      jj_consume_token(COLON);
      parseName();
    } catch (...) {      
        
        if (jjtc000) {
          jjtree.clearNodeScope(jjtn000);
          jjtc000 = false;
        } else {
          jjtree.popNode();
        }
    
    
    
    
    
         
      
    }

    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      if (jjtree.nodeCreated()) {
       jjtreeCloseNodeScope(jjtn000);
      }
    }





     
  
}


void Expression::parseAttribute() {/*@bgen(jjtree) ATTRIBUTE */
  SimpleNode *jjtn000 = new SimpleNode(JJTATTRIBUTE);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);



                               
/*@egen*/

    try {
      parseName();
    } catch (...) {      
        
        if (jjtc000) {
          jjtree.clearNodeScope(jjtn000);
          jjtc000 = false;
        } else {
          jjtree.popNode();
        }
    
    
    
    
    
         
      
    }

    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      if (jjtree.nodeCreated()) {
       jjtreeCloseNodeScope(jjtn000);
      }
    }





     
  
}


void Expression::parseFunction() {/*@bgen(jjtree) FUNCTION */
  SimpleNode *jjtn000 = new SimpleNode(JJTFUNCTION);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);



                               
/*@egen*/

    try {
      parseName();
      jj_consume_token(LP);
      switch (jj_nt->kind) {
      case LP:
      case COLON:
      case DOLLAR:
      case NULL_TOKEN:
      case BOOL_TOKEN:
      case OCTAL_TOKEN:
      case INTEGER_TOKEN:
      case HEXADECIMAL_TOKEN:
      case DECIMAL_TOKEN:
      case UUID_TOKEN:
      case STRING_TOKEN:
      case LOCALTIME_TOKEN:
      case LOCALDATE_TOKEN:
      case LOCALDATETIME_TOKEN:
      case OFFSETTIME_TOKEN:
      case OFFSETDATETIME_TOKEN:
      case SRID_TOKEN:
      case POINT_TOKEN:
      case POLYGON_TOKEN:
      case LINESTRING_TOKEN:
      case MULTIPOINT_TOKEN:
      case MULTIPOLYGON_TOKEN:
      case MULTILINESTRING_TOKEN:
      case GEOMETRYCOLLECTION_TOKEN:
      case ENVELOPE_TOKEN:
      case ADD:
      case SUB:
      case NOT:
      case BBOX:
      case RELATE:
      case EQUALS:
      case BEYOND:
      case WITHIN:
      case DWITHIN:
      case TOUCHES:
      case CROSSES:
      case CONTAINS:
      case OVERLAPS:
      case DISJOINT:
      case INTERSECTS:
      case IDENTIFIER_TOKEN:
      case IDENTIFIER_QUOTED_TOKEN:{
        parseExpressionList();
        break;
        }
      default:
        jj_la1[37] = jj_gen;
        ;
      }
      jj_consume_token(RP);
    } catch (...) {      
        
        if (jjtc000) {
          jjtree.clearNodeScope(jjtn000);
          jjtc000 = false;
        } else {
          jjtree.popNode();
        }
    
    
    
    
    
         
      
    }

    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      if (jjtree.nodeCreated()) {
       jjtreeCloseNodeScope(jjtn000);
      }
    }





     
  
}


void Expression::compileFilter() {
    parseFilter();
    jj_consume_token(0);
}


void Expression::parseFilter() {/*@bgen(jjtree) OR */
  SimpleNode *jjtn000 = new SimpleNode(JJTOR);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);



                               
/*@egen*/

    try {
      parseAndFilter();
      while (!hasError) {
        switch (jj_nt->kind) {
        case OR:{
          ;
          break;
          }
        default:
          jj_la1[38] = jj_gen;
          goto end_label_11;
        }
        jj_consume_token(OR);
        parseAndFilter();
      }
      end_label_11: ;
    } catch (...) {      
        
        if (jjtc000) {
          jjtree.clearNodeScope(jjtn000);
          jjtc000 = false;
        } else {
          jjtree.popNode();
        }
    
    
    
    
    
         
      
    }

    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      if (jjtree.nodeCreated()) {
       jjtreeCloseNodeScope(jjtn000);
      }
    }





     
  
}


void Expression::parseAndFilter() {/*@bgen(jjtree) AND */
  SimpleNode *jjtn000 = new SimpleNode(JJTAND);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);



                               
/*@egen*/

    try {
      parseNotFilter();
      while (!hasError) {
        switch (jj_nt->kind) {
        case AND:{
          ;
          break;
          }
        default:
          jj_la1[39] = jj_gen;
          goto end_label_12;
        }
        jj_consume_token(AND);
        parseNotFilter();
      }
      end_label_12: ;
    } catch (...) {      
        
        if (jjtc000) {
          jjtree.clearNodeScope(jjtn000);
          jjtc000 = false;
        } else {
          jjtree.popNode();
        }
    
    
    
    
    
         
      
    }

    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      if (jjtree.nodeCreated()) {
       jjtreeCloseNodeScope(jjtn000);
      }
    }





     
  
}


void Expression::parseNotFilter() {
    switch (jj_nt->kind) {
    case NOT:{
      jj_consume_token(NOT);

            SimpleNode *jjtn001 = new SimpleNode(JJTNOT);
            bool jjtc001 = true;
            jjtree.openNodeScope(jjtn001);
            jjtreeOpenNodeScope(jjtn001);



                                         
          
      try {
        parsePredicate();
      } catch (...) {      
                  
                  if (jjtc001) {
                    jjtree.clearNodeScope(jjtn001);
                    jjtc001 = false;
                  } else {
                    jjtree.popNode();
                  }
      
      
      
      
      
                   
                
      }

            if (jjtc001) {
              jjtree.closeNodeScope(jjtn001, true);
              if (jjtree.nodeCreated()) {
               jjtreeCloseNodeScope(jjtn001);
              }
            }





             
          
      break;
      }
    case LP:
    case COLON:
    case DOLLAR:
    case NULL_TOKEN:
    case BOOL_TOKEN:
    case OCTAL_TOKEN:
    case INTEGER_TOKEN:
    case HEXADECIMAL_TOKEN:
    case DECIMAL_TOKEN:
    case UUID_TOKEN:
    case STRING_TOKEN:
    case LOCALTIME_TOKEN:
    case LOCALDATE_TOKEN:
    case LOCALDATETIME_TOKEN:
    case OFFSETTIME_TOKEN:
    case OFFSETDATETIME_TOKEN:
    case SRID_TOKEN:
    case POINT_TOKEN:
    case POLYGON_TOKEN:
    case LINESTRING_TOKEN:
    case MULTIPOINT_TOKEN:
    case MULTIPOLYGON_TOKEN:
    case MULTILINESTRING_TOKEN:
    case GEOMETRYCOLLECTION_TOKEN:
    case ENVELOPE_TOKEN:
    case ADD:
    case SUB:
    case BBOX:
    case RELATE:
    case EQUALS:
    case BEYOND:
    case WITHIN:
    case DWITHIN:
    case TOUCHES:
    case CROSSES:
    case CONTAINS:
    case OVERLAPS:
    case DISJOINT:
    case INTERSECTS:
    case IDENTIFIER_TOKEN:
    case IDENTIFIER_QUOTED_TOKEN:{
      parsePredicate();
      break;
      }
    default:
      jj_la1[40] = jj_gen;
      jj_consume_token(-1);
      errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
    }
}


void Expression::parsePredicate() {
    switch (jj_nt->kind) {
    case BOOL_TOKEN:{
      parseBool();
      break;
      }
    case BBOX:
    case RELATE:
    case EQUALS:
    case BEYOND:
    case WITHIN:
    case DWITHIN:
    case TOUCHES:
    case CROSSES:
    case CONTAINS:
    case OVERLAPS:
    case DISJOINT:
    case INTERSECTS:{

    SimpleNode *jjtn001 = new SimpleNode(JJTSPATIAL_PREDICATE);
    bool jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    jjtreeOpenNodeScope(jjtn001);



                                 
  
      try {
        parseSpatialPredicate();
      } catch (...) {      
          
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
      
      
      
      
      
           
        
      }

    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, true);
      if (jjtree.nodeCreated()) {
       jjtreeCloseNodeScope(jjtn001);
      }
    }





     
  
      break;
      }
    default:
      jj_la1[41] = jj_gen;
      if (jj_2_2(2147483647)) {

                                      SimpleNode *jjtn002 = new SimpleNode(JJTEXISTS);
                                      bool jjtc002 = true;
                                      jjtree.openNodeScope(jjtn002);
                                      jjtreeOpenNodeScope(jjtn002);



                                                                   
                                    
        try {
          parseExistsPredicate();
        } catch (...) {      
                                              
                                              if (jjtc002) {
                                                jjtree.clearNodeScope(jjtn002);
                                                jjtc002 = false;
                                              } else {
                                                jjtree.popNode();
                                              }
        
        
        
        
        
                                               
                                            
        }

                                      if (jjtc002) {
                                        jjtree.closeNodeScope(jjtn002, true);
                                        if (jjtree.nodeCreated()) {
                                         jjtreeCloseNodeScope(jjtn002);
                                        }
                                      }





                                       
                                    
      } else if (jj_2_3(2147483647)) {
        parseRelationalPredicate();
      } else {
        switch (jj_nt->kind) {
        case LP:
        case COLON:
        case DOLLAR:
        case NULL_TOKEN:
        case OCTAL_TOKEN:
        case INTEGER_TOKEN:
        case HEXADECIMAL_TOKEN:
        case DECIMAL_TOKEN:
        case UUID_TOKEN:
        case STRING_TOKEN:
        case LOCALTIME_TOKEN:
        case LOCALDATE_TOKEN:
        case LOCALDATETIME_TOKEN:
        case OFFSETTIME_TOKEN:
        case OFFSETDATETIME_TOKEN:
        case SRID_TOKEN:
        case POINT_TOKEN:
        case POLYGON_TOKEN:
        case LINESTRING_TOKEN:
        case MULTIPOINT_TOKEN:
        case MULTIPOLYGON_TOKEN:
        case MULTILINESTRING_TOKEN:
        case GEOMETRYCOLLECTION_TOKEN:
        case ENVELOPE_TOKEN:
        case ADD:
        case SUB:
        case IDENTIFIER_TOKEN:
        case IDENTIFIER_QUOTED_TOKEN:{
          parseExpression();
          break;
          }
        default:
          jj_la1[42] = jj_gen;
          jj_consume_token(-1);
          errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
        }
      }
    }
}


void Expression::parseExistsPredicate() {
    parseNamedExpression();
    parseExistsOperator();
}


void Expression::parseExistsOperator() {
    switch (jj_nt->kind) {
    case EXISTS:{

    SimpleNode *jjtn001 = new SimpleNode(JJTEXISTS_OPERATOR);
    bool jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    jjtreeOpenNodeScope(jjtn001);



                                 
  
      try {
        jj_consume_token(EXISTS);
      } catch (...) {      
          
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
      
      
      
      
      
           
        
      }

    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, true);
      if (jjtree.nodeCreated()) {
       jjtreeCloseNodeScope(jjtn001);
      }
    }





     
  
      break;
      }
    case NOT:{
      jj_consume_token(NOT);

            SimpleNode *jjtn002 = new SimpleNode(JJTNOTEXISTS_OPERATOR);
            bool jjtc002 = true;
            jjtree.openNodeScope(jjtn002);
            jjtreeOpenNodeScope(jjtn002);



                                         
          
      try {
        jj_consume_token(EXISTS);
      } catch (...) {      
                  
                  if (jjtc002) {
                    jjtree.clearNodeScope(jjtn002);
                    jjtc002 = false;
                  } else {
                    jjtree.popNode();
                  }
      
      
      
      
      
                   
                
      }

            if (jjtc002) {
              jjtree.closeNodeScope(jjtn002, true);
              if (jjtree.nodeCreated()) {
               jjtreeCloseNodeScope(jjtn002);
              }
            }





             
          
      break;
      }
    default:
      jj_la1[43] = jj_gen;
      jj_consume_token(-1);
      errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
    }
}


void Expression::parseRelationalPredicate() {/*@bgen(jjtree) RELATIONAL_PREDICATE */
  SimpleNode *jjtn000 = new SimpleNode(JJTRELATIONAL_PREDICATE);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);



                               
/*@egen*/

    try {
      parseExpression();
      parseRelationalPredicatePart();
    } catch (...) {      
        
        if (jjtc000) {
          jjtree.clearNodeScope(jjtn000);
          jjtc000 = false;
        } else {
          jjtree.popNode();
        }
    
    
    
    
    
         
      
    }

    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      if (jjtree.nodeCreated()) {
       jjtreeCloseNodeScope(jjtn000);
      }
    }





     
  
}


void Expression::parseRelationalPredicatePart() {
    switch (jj_nt->kind) {
    case IS:{
      parseIsNullPredicate();
      break;
      }
    case EQ:
    case LT:
    case GT:
    case NEQ:
    case LTE:
    case GTE:{
      parseComparisionPredicate();
      break;
      }
    default:
      jj_la1[44] = jj_gen;
      if (jj_2_4(2147483647)) {
        parseLikePredicate();
      } else if (jj_2_5(2147483647)) {
        parseBetweenPredicate();
      } else {
        switch (jj_nt->kind) {
        case NOT:
        case IN:{
          parseInPredicate();
          break;
          }
        default:
          jj_la1[45] = jj_gen;
          jj_consume_token(-1);
          errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
        }
      }
    }
}


void Expression::parseComparisionPredicate() {
    parseComparisionOperator();
    parseExpression();
}


void Expression::parseComparisionOperator() {
    switch (jj_nt->kind) {
    case EQ:{

    SimpleNode *jjtn001 = new SimpleNode(JJTEQUAL_OPERATOR);
    bool jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    jjtreeOpenNodeScope(jjtn001);



                                 
  
      try {
        jj_consume_token(EQ);
      } catch (...) {      
          
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
      
      
      
      
      
           
        
      }

    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, true);
      if (jjtree.nodeCreated()) {
       jjtreeCloseNodeScope(jjtn001);
      }
    }





     
  
      break;
      }
    case NEQ:{

    SimpleNode *jjtn002 = new SimpleNode(JJTNOTEQUAL_OPERATOR);
    bool jjtc002 = true;
    jjtree.openNodeScope(jjtn002);
    jjtreeOpenNodeScope(jjtn002);



                                 
  
      try {
        jj_consume_token(NEQ);
      } catch (...) {      
          
          if (jjtc002) {
            jjtree.clearNodeScope(jjtn002);
            jjtc002 = false;
          } else {
            jjtree.popNode();
          }
      
      
      
      
      
           
        
      }

    if (jjtc002) {
      jjtree.closeNodeScope(jjtn002, true);
      if (jjtree.nodeCreated()) {
       jjtreeCloseNodeScope(jjtn002);
      }
    }





     
  
      break;
      }
    case LT:{

    SimpleNode *jjtn003 = new SimpleNode(JJTLESS_OPERATOR);
    bool jjtc003 = true;
    jjtree.openNodeScope(jjtn003);
    jjtreeOpenNodeScope(jjtn003);



                                 
  
      try {
        jj_consume_token(LT);
      } catch (...) {      
          
          if (jjtc003) {
            jjtree.clearNodeScope(jjtn003);
            jjtc003 = false;
          } else {
            jjtree.popNode();
          }
      
      
      
      
      
           
        
      }

    if (jjtc003) {
      jjtree.closeNodeScope(jjtn003, true);
      if (jjtree.nodeCreated()) {
       jjtreeCloseNodeScope(jjtn003);
      }
    }





     
  
      break;
      }
    case LTE:{

    SimpleNode *jjtn004 = new SimpleNode(JJTLESSEQUAL_OPERATOR);
    bool jjtc004 = true;
    jjtree.openNodeScope(jjtn004);
    jjtreeOpenNodeScope(jjtn004);



                                 
  
      try {
        jj_consume_token(LTE);
      } catch (...) {      
          
          if (jjtc004) {
            jjtree.clearNodeScope(jjtn004);
            jjtc004 = false;
          } else {
            jjtree.popNode();
          }
      
      
      
      
      
           
        
      }

    if (jjtc004) {
      jjtree.closeNodeScope(jjtn004, true);
      if (jjtree.nodeCreated()) {
       jjtreeCloseNodeScope(jjtn004);
      }
    }





     
  
      break;
      }
    case GT:{

    SimpleNode *jjtn005 = new SimpleNode(JJTGREATER_OPERATOR);
    bool jjtc005 = true;
    jjtree.openNodeScope(jjtn005);
    jjtreeOpenNodeScope(jjtn005);



                                 
  
      try {
        jj_consume_token(GT);
      } catch (...) {      
          
          if (jjtc005) {
            jjtree.clearNodeScope(jjtn005);
            jjtc005 = false;
          } else {
            jjtree.popNode();
          }
      
      
      
      
      
           
        
      }

    if (jjtc005) {
      jjtree.closeNodeScope(jjtn005, true);
      if (jjtree.nodeCreated()) {
       jjtreeCloseNodeScope(jjtn005);
      }
    }





     
  
      break;
      }
    case GTE:{

    SimpleNode *jjtn006 = new SimpleNode(JJTGREATEREQUAL_OPERATOR);
    bool jjtc006 = true;
    jjtree.openNodeScope(jjtn006);
    jjtreeOpenNodeScope(jjtn006);



                                 
  
      try {
        jj_consume_token(GTE);
      } catch (...) {      
          
          if (jjtc006) {
            jjtree.clearNodeScope(jjtn006);
            jjtc006 = false;
          } else {
            jjtree.popNode();
          }
      
      
      
      
      
           
        
      }

    if (jjtc006) {
      jjtree.closeNodeScope(jjtn006, true);
      if (jjtree.nodeCreated()) {
       jjtreeCloseNodeScope(jjtn006);
      }
    }





     
  
      break;
      }
    default:
      jj_la1[46] = jj_gen;
      jj_consume_token(-1);
      errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
    }
}


void Expression::parseIsNullPredicate() {
    jj_consume_token(IS);
    parseIsNullOperator();
}


void Expression::parseIsNullOperator() {
    switch (jj_nt->kind) {
    case NULL_TOKEN:{

    SimpleNode *jjtn001 = new SimpleNode(JJTISNULL_OPERATOR);
    bool jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    jjtreeOpenNodeScope(jjtn001);



                                 
  
      try {
        jj_consume_token(NULL_TOKEN);
      } catch (...) {      
          
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
      
      
      
      
      
           
        
      }

    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, true);
      if (jjtree.nodeCreated()) {
       jjtreeCloseNodeScope(jjtn001);
      }
    }





     
  
      break;
      }
    case NOT:{
      jj_consume_token(NOT);

            SimpleNode *jjtn002 = new SimpleNode(JJTISNOTNULL_OPERATOR);
            bool jjtc002 = true;
            jjtree.openNodeScope(jjtn002);
            jjtreeOpenNodeScope(jjtn002);



                                         
          
      try {
        jj_consume_token(NULL_TOKEN);
      } catch (...) {      
                  
                  if (jjtc002) {
                    jjtree.clearNodeScope(jjtn002);
                    jjtc002 = false;
                  } else {
                    jjtree.popNode();
                  }
      
      
      
      
      
                   
                
      }

            if (jjtc002) {
              jjtree.closeNodeScope(jjtn002, true);
              if (jjtree.nodeCreated()) {
               jjtreeCloseNodeScope(jjtn002);
              }
            }





             
          
      break;
      }
    default:
      jj_la1[47] = jj_gen;
      jj_consume_token(-1);
      errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
    }
}


void Expression::parseLikePredicate() {
    parseLikeOperator();
    parseLikePattern();
}


void Expression::parseLikeOperator() {
    switch (jj_nt->kind) {
    case ILIKE:{

    SimpleNode *jjtn001 = new SimpleNode(JJTILIKE_OPERATOR);
    bool jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    jjtreeOpenNodeScope(jjtn001);



                                 
  
      try {
        jj_consume_token(ILIKE);
      } catch (...) {      
          
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
      
      
      
      
      
           
        
      }

    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, true);
      if (jjtree.nodeCreated()) {
       jjtreeCloseNodeScope(jjtn001);
      }
    }





     
  
      break;
      }
    case LIKE:{

    SimpleNode *jjtn002 = new SimpleNode(JJTLIKE_OPERATOR);
    bool jjtc002 = true;
    jjtree.openNodeScope(jjtn002);
    jjtreeOpenNodeScope(jjtn002);



                                 
  
      try {
        jj_consume_token(LIKE);
      } catch (...) {      
          
          if (jjtc002) {
            jjtree.clearNodeScope(jjtn002);
            jjtc002 = false;
          } else {
            jjtree.popNode();
          }
      
      
      
      
      
           
        
      }

    if (jjtc002) {
      jjtree.closeNodeScope(jjtn002, true);
      if (jjtree.nodeCreated()) {
       jjtreeCloseNodeScope(jjtn002);
      }
    }





     
  
      break;
      }
    default:
      jj_la1[48] = jj_gen;
      if (jj_2_6(2)) {
        jj_consume_token(NOT);

                         SimpleNode *jjtn003 = new SimpleNode(JJTNOTLIKE_OPERATOR);
                         bool jjtc003 = true;
                         jjtree.openNodeScope(jjtn003);
                         jjtreeOpenNodeScope(jjtn003);



                                                      
                       
        try {
          jj_consume_token(LIKE);
        } catch (...) {      
                                 
                                 if (jjtc003) {
                                   jjtree.clearNodeScope(jjtn003);
                                   jjtc003 = false;
                                 } else {
                                   jjtree.popNode();
                                 }
        
        
        
        
        
                                  
                               
        }

                         if (jjtc003) {
                           jjtree.closeNodeScope(jjtn003, true);
                           if (jjtree.nodeCreated()) {
                            jjtreeCloseNodeScope(jjtn003);
                           }
                         }





                          
                       
      } else {
        switch (jj_nt->kind) {
        case NOT:{
          jj_consume_token(NOT);

            SimpleNode *jjtn004 = new SimpleNode(JJTNOTILIKE_OPERATOR);
            bool jjtc004 = true;
            jjtree.openNodeScope(jjtn004);
            jjtreeOpenNodeScope(jjtn004);



                                         
          
          try {
            jj_consume_token(ILIKE);
          } catch (...) {      
                      
                      if (jjtc004) {
                        jjtree.clearNodeScope(jjtn004);
                        jjtc004 = false;
                      } else {
                        jjtree.popNode();
                      }
          
          
          
          
          
                       
                    
          }

            if (jjtc004) {
              jjtree.closeNodeScope(jjtn004, true);
              if (jjtree.nodeCreated()) {
               jjtreeCloseNodeScope(jjtn004);
              }
            }





             
          
          break;
          }
        default:
          jj_la1[49] = jj_gen;
          jj_consume_token(-1);
          errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
        }
      }
    }
}


void Expression::parseLikePattern() {
    switch (jj_nt->kind) {
    case STRING_TOKEN:{
      parseString();
      break;
      }
    case REGEXP_TOKEN:{
      parseRegExp();
      break;
      }
    default:
      jj_la1[50] = jj_gen;
      jj_consume_token(-1);
      errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
    }
}


void Expression::parseBetweenPredicate() {
    parseBetweenOperator();
    parseExpression();
    jj_consume_token(AND);
    parseExpression();
}


void Expression::parseBetweenOperator() {
    switch (jj_nt->kind) {
    case BETWEEN:{

    SimpleNode *jjtn001 = new SimpleNode(JJTBETWEEN_OPERATOR);
    bool jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    jjtreeOpenNodeScope(jjtn001);



                                 
  
      try {
        jj_consume_token(BETWEEN);
      } catch (...) {      
          
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
      
      
      
      
      
           
        
      }

    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, true);
      if (jjtree.nodeCreated()) {
       jjtreeCloseNodeScope(jjtn001);
      }
    }





     
  
      break;
      }
    case NOT:{
      jj_consume_token(NOT);

            SimpleNode *jjtn002 = new SimpleNode(JJTNOTBETWEEN_OPERATOR);
            bool jjtc002 = true;
            jjtree.openNodeScope(jjtn002);
            jjtreeOpenNodeScope(jjtn002);



                                         
          
      try {
        jj_consume_token(BETWEEN);
      } catch (...) {      
                  
                  if (jjtc002) {
                    jjtree.clearNodeScope(jjtn002);
                    jjtc002 = false;
                  } else {
                    jjtree.popNode();
                  }
      
      
      
      
      
                   
                
      }

            if (jjtc002) {
              jjtree.closeNodeScope(jjtn002, true);
              if (jjtree.nodeCreated()) {
               jjtreeCloseNodeScope(jjtn002);
              }
            }





             
          
      break;
      }
    default:
      jj_la1[51] = jj_gen;
      jj_consume_token(-1);
      errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
    }
}


void Expression::parseInPredicate() {
    parseInOperator();
    jj_consume_token(LP);
    parseInPredicateList();
    jj_consume_token(RP);
}


void Expression::parseInOperator() {
    switch (jj_nt->kind) {
    case IN:{

    SimpleNode *jjtn001 = new SimpleNode(JJTIN_OPERATOR);
    bool jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    jjtreeOpenNodeScope(jjtn001);



                                 
  
      try {
        jj_consume_token(IN);
      } catch (...) {      
          
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
      
      
      
      
      
           
        
      }

    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, true);
      if (jjtree.nodeCreated()) {
       jjtreeCloseNodeScope(jjtn001);
      }
    }





     
  
      break;
      }
    case NOT:{
      jj_consume_token(NOT);

            SimpleNode *jjtn002 = new SimpleNode(JJTNOTIN_OPERATOR);
            bool jjtc002 = true;
            jjtree.openNodeScope(jjtn002);
            jjtreeOpenNodeScope(jjtn002);



                                         
          
      try {
        jj_consume_token(IN);
      } catch (...) {      
                  
                  if (jjtc002) {
                    jjtree.clearNodeScope(jjtn002);
                    jjtc002 = false;
                  } else {
                    jjtree.popNode();
                  }
      
      
      
      
      
                   
                
      }

            if (jjtc002) {
              jjtree.closeNodeScope(jjtn002, true);
              if (jjtree.nodeCreated()) {
               jjtreeCloseNodeScope(jjtn002);
              }
            }





             
          
      break;
      }
    default:
      jj_la1[52] = jj_gen;
      jj_consume_token(-1);
      errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
    }
}


void Expression::parseInPredicateList() {/*@bgen(jjtree) LITERALLIST */
  SimpleNode *jjtn000 = new SimpleNode(JJTLITERALLIST);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);



                               
/*@egen*/

    try {
      parseInPredicateItem();
      while (!hasError) {
        switch (jj_nt->kind) {
        case COMMA:{
          ;
          break;
          }
        default:
          jj_la1[53] = jj_gen;
          goto end_label_13;
        }
        jj_consume_token(COMMA);
        parseInPredicateItem();
      }
      end_label_13: ;
    } catch (...) {      
        
        if (jjtc000) {
          jjtree.clearNodeScope(jjtn000);
          jjtc000 = false;
        } else {
          jjtree.popNode();
        }
    
    
    
    
    
         
      
    }

    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      if (jjtree.nodeCreated()) {
       jjtreeCloseNodeScope(jjtn000);
      }
    }





     
  
}


void Expression::parseInPredicateItem() {
    switch (jj_nt->kind) {
    case OCTAL_TOKEN:
    case INTEGER_TOKEN:
    case HEXADECIMAL_TOKEN:
    case DECIMAL_TOKEN:
    case UUID_TOKEN:
    case STRING_TOKEN:
    case LOCALTIME_TOKEN:
    case LOCALDATE_TOKEN:
    case LOCALDATETIME_TOKEN:
    case OFFSETTIME_TOKEN:
    case OFFSETDATETIME_TOKEN:
    case SRID_TOKEN:
    case POINT_TOKEN:
    case POLYGON_TOKEN:
    case LINESTRING_TOKEN:
    case MULTIPOINT_TOKEN:
    case MULTIPOLYGON_TOKEN:
    case MULTILINESTRING_TOKEN:
    case GEOMETRYCOLLECTION_TOKEN:
    case ENVELOPE_TOKEN:
    case ADD:
    case SUB:{
      parseLiteral();
      break;
      }
    case COLON:{
      parseBinding();
      break;
      }
    case DOLLAR:{
      parseParameter();
      break;
      }
    default:
      jj_la1[54] = jj_gen;
      jj_consume_token(-1);
      errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
    }
}


void Expression::parseSpatialPredicate() {
    switch (jj_nt->kind) {
    case BBOX:{
      jj_consume_token(BBOX);

             SimpleNode *jjtn001 = new SimpleNode(JJTST_BBOX_OPERATOR);
             bool jjtc001 = true;
             jjtree.openNodeScope(jjtn001);
             jjtreeOpenNodeScope(jjtn001);



                                          
           
      try {
        parseBBoxArguments();
      } catch (...) {      
                   
                   if (jjtc001) {
                     jjtree.clearNodeScope(jjtn001);
                     jjtc001 = false;
                   } else {
                     jjtree.popNode();
                   }
      
      
      
      
      
                    
                 
      }

             if (jjtc001) {
               jjtree.closeNodeScope(jjtn001, true);
               if (jjtree.nodeCreated()) {
                jjtreeCloseNodeScope(jjtn001);
               }
             }





              
           
      break;
      }
    case RELATE:{
      jj_consume_token(RELATE);

               SimpleNode *jjtn002 = new SimpleNode(JJTST_RELATE_OPERATOR);
               bool jjtc002 = true;
               jjtree.openNodeScope(jjtn002);
               jjtreeOpenNodeScope(jjtn002);



                                            
             
      try {
        parseRelateArguments();
      } catch (...) {      
                     
                     if (jjtc002) {
                       jjtree.clearNodeScope(jjtn002);
                       jjtc002 = false;
                     } else {
                       jjtree.popNode();
                     }
      
      
      
      
      
                      
                   
      }

               if (jjtc002) {
                 jjtree.closeNodeScope(jjtn002, true);
                 if (jjtree.nodeCreated()) {
                  jjtreeCloseNodeScope(jjtn002);
                 }
               }





                
             
      break;
      }
    case CONTAINS:{
      jj_consume_token(CONTAINS);

                 SimpleNode *jjtn003 = new SimpleNode(JJTST_CONTAINS_OPERATOR);
                 bool jjtc003 = true;
                 jjtree.openNodeScope(jjtn003);
                 jjtreeOpenNodeScope(jjtn003);



                                              
               
      try {
        parseSpatialArguments();
      } catch (...) {      
                       
                       if (jjtc003) {
                         jjtree.clearNodeScope(jjtn003);
                         jjtc003 = false;
                       } else {
                         jjtree.popNode();
                       }
      
      
      
      
      
                        
                     
      }

                 if (jjtc003) {
                   jjtree.closeNodeScope(jjtn003, true);
                   if (jjtree.nodeCreated()) {
                    jjtreeCloseNodeScope(jjtn003);
                   }
                 }





                  
               
      break;
      }
    case CROSSES:{
      jj_consume_token(CROSSES);

                SimpleNode *jjtn004 = new SimpleNode(JJTST_CROSSES_OPERATOR);
                bool jjtc004 = true;
                jjtree.openNodeScope(jjtn004);
                jjtreeOpenNodeScope(jjtn004);



                                             
              
      try {
        parseSpatialArguments();
      } catch (...) {      
                      
                      if (jjtc004) {
                        jjtree.clearNodeScope(jjtn004);
                        jjtc004 = false;
                      } else {
                        jjtree.popNode();
                      }
      
      
      
      
      
                       
                    
      }

                if (jjtc004) {
                  jjtree.closeNodeScope(jjtn004, true);
                  if (jjtree.nodeCreated()) {
                   jjtreeCloseNodeScope(jjtn004);
                  }
                }





                 
              
      break;
      }
    case DISJOINT:{
      jj_consume_token(DISJOINT);

                 SimpleNode *jjtn005 = new SimpleNode(JJTST_DISJOINT_OPERATOR);
                 bool jjtc005 = true;
                 jjtree.openNodeScope(jjtn005);
                 jjtreeOpenNodeScope(jjtn005);



                                              
               
      try {
        parseSpatialArguments();
      } catch (...) {      
                       
                       if (jjtc005) {
                         jjtree.clearNodeScope(jjtn005);
                         jjtc005 = false;
                       } else {
                         jjtree.popNode();
                       }
      
      
      
      
      
                        
                     
      }

                 if (jjtc005) {
                   jjtree.closeNodeScope(jjtn005, true);
                   if (jjtree.nodeCreated()) {
                    jjtreeCloseNodeScope(jjtn005);
                   }
                 }





                  
               
      break;
      }
    case EQUALS:{
      jj_consume_token(EQUALS);

               SimpleNode *jjtn006 = new SimpleNode(JJTST_EQUALS_OPERATOR);
               bool jjtc006 = true;
               jjtree.openNodeScope(jjtn006);
               jjtreeOpenNodeScope(jjtn006);



                                            
             
      try {
        parseSpatialArguments();
      } catch (...) {      
                     
                     if (jjtc006) {
                       jjtree.clearNodeScope(jjtn006);
                       jjtc006 = false;
                     } else {
                       jjtree.popNode();
                     }
      
      
      
      
      
                      
                   
      }

               if (jjtc006) {
                 jjtree.closeNodeScope(jjtn006, true);
                 if (jjtree.nodeCreated()) {
                  jjtreeCloseNodeScope(jjtn006);
                 }
               }





                
             
      break;
      }
    case INTERSECTS:{
      jj_consume_token(INTERSECTS);

                   SimpleNode *jjtn007 = new SimpleNode(JJTST_INTERSECTS_OPERATOR);
                   bool jjtc007 = true;
                   jjtree.openNodeScope(jjtn007);
                   jjtreeOpenNodeScope(jjtn007);



                                                
                 
      try {
        parseSpatialArguments();
      } catch (...) {      
                         
                         if (jjtc007) {
                           jjtree.clearNodeScope(jjtn007);
                           jjtc007 = false;
                         } else {
                           jjtree.popNode();
                         }
      
      
      
      
      
                          
                       
      }

                   if (jjtc007) {
                     jjtree.closeNodeScope(jjtn007, true);
                     if (jjtree.nodeCreated()) {
                      jjtreeCloseNodeScope(jjtn007);
                     }
                   }





                    
                 
      break;
      }
    case OVERLAPS:{
      jj_consume_token(OVERLAPS);

                 SimpleNode *jjtn008 = new SimpleNode(JJTST_OVERLAPS_OPERATOR);
                 bool jjtc008 = true;
                 jjtree.openNodeScope(jjtn008);
                 jjtreeOpenNodeScope(jjtn008);



                                              
               
      try {
        parseSpatialArguments();
      } catch (...) {      
                       
                       if (jjtc008) {
                         jjtree.clearNodeScope(jjtn008);
                         jjtc008 = false;
                       } else {
                         jjtree.popNode();
                       }
      
      
      
      
      
                        
                     
      }

                 if (jjtc008) {
                   jjtree.closeNodeScope(jjtn008, true);
                   if (jjtree.nodeCreated()) {
                    jjtreeCloseNodeScope(jjtn008);
                   }
                 }





                  
               
      break;
      }
    case TOUCHES:{
      jj_consume_token(TOUCHES);

                SimpleNode *jjtn009 = new SimpleNode(JJTST_TOUCHES_OPERATOR);
                bool jjtc009 = true;
                jjtree.openNodeScope(jjtn009);
                jjtreeOpenNodeScope(jjtn009);



                                             
              
      try {
        parseSpatialArguments();
      } catch (...) {      
                      
                      if (jjtc009) {
                        jjtree.clearNodeScope(jjtn009);
                        jjtc009 = false;
                      } else {
                        jjtree.popNode();
                      }
      
      
      
      
      
                       
                    
      }

                if (jjtc009) {
                  jjtree.closeNodeScope(jjtn009, true);
                  if (jjtree.nodeCreated()) {
                   jjtreeCloseNodeScope(jjtn009);
                  }
                }





                 
              
      break;
      }
    case WITHIN:{
      jj_consume_token(WITHIN);

               SimpleNode *jjtn010 = new SimpleNode(JJTST_WITHIN_OPERATOR);
               bool jjtc010 = true;
               jjtree.openNodeScope(jjtn010);
               jjtreeOpenNodeScope(jjtn010);



                                            
             
      try {
        parseSpatialArguments();
      } catch (...) {      
                     
                     if (jjtc010) {
                       jjtree.clearNodeScope(jjtn010);
                       jjtc010 = false;
                     } else {
                       jjtree.popNode();
                     }
      
      
      
      
      
                      
                   
      }

               if (jjtc010) {
                 jjtree.closeNodeScope(jjtn010, true);
                 if (jjtree.nodeCreated()) {
                  jjtreeCloseNodeScope(jjtn010);
                 }
               }





                
             
      break;
      }
    case BEYOND:{
      jj_consume_token(BEYOND);

               SimpleNode *jjtn011 = new SimpleNode(JJTST_BEYOND_OPERATOR);
               bool jjtc011 = true;
               jjtree.openNodeScope(jjtn011);
               jjtreeOpenNodeScope(jjtn011);



                                            
             
      try {
        parseSpatialDistanceArguments();
      } catch (...) {      
                     
                     if (jjtc011) {
                       jjtree.clearNodeScope(jjtn011);
                       jjtc011 = false;
                     } else {
                       jjtree.popNode();
                     }
      
      
      
      
      
                      
                   
      }

               if (jjtc011) {
                 jjtree.closeNodeScope(jjtn011, true);
                 if (jjtree.nodeCreated()) {
                  jjtreeCloseNodeScope(jjtn011);
                 }
               }





                
             
      break;
      }
    case DWITHIN:{
      jj_consume_token(DWITHIN);

                SimpleNode *jjtn012 = new SimpleNode(JJTST_DWITHIN_OPERATOR);
                bool jjtc012 = true;
                jjtree.openNodeScope(jjtn012);
                jjtreeOpenNodeScope(jjtn012);



                                             
              
      try {
        parseSpatialDistanceArguments();
      } catch (...) {      
                      
                      if (jjtc012) {
                        jjtree.clearNodeScope(jjtn012);
                        jjtc012 = false;
                      } else {
                        jjtree.popNode();
                      }
      
      
      
      
      
                       
                    
      }

                if (jjtc012) {
                  jjtree.closeNodeScope(jjtn012, true);
                  if (jjtree.nodeCreated()) {
                   jjtreeCloseNodeScope(jjtn012);
                  }
                }





                 
              
      break;
      }
    default:
      jj_la1[55] = jj_gen;
      jj_consume_token(-1);
      errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
    }
}


void Expression::parseBBoxArguments() {
    jj_consume_token(LP);
    parseExpression();
    jj_consume_token(COMMA);
    parseNumber();
    jj_consume_token(COMMA);
    parseNumber();
    jj_consume_token(COMMA);
    parseNumber();
    jj_consume_token(COMMA);
    parseNumber();
    switch (jj_nt->kind) {
    case COMMA:{
      jj_consume_token(COMMA);
      parseString();
      break;
      }
    default:
      jj_la1[56] = jj_gen;
      ;
    }
    jj_consume_token(RP);
}


void Expression::parseRelateArguments() {
    jj_consume_token(LP);
    parseExpression();
    jj_consume_token(COMMA);
    parseExpression();
    jj_consume_token(COMMA);
    parseDE9IM();
    jj_consume_token(RP);
}


void Expression::parseSpatialArguments() {
    jj_consume_token(LP);
    parseExpression();
    jj_consume_token(COMMA);
    parseExpression();
    jj_consume_token(RP);
}


void Expression::parseSpatialDistanceArguments() {
    jj_consume_token(LP);
    parseExpression();
    jj_consume_token(COMMA);
    parseExpression();
    jj_consume_token(COMMA);
    parseNumber();
    jj_consume_token(COMMA);
    parseDistanceUnits();
    jj_consume_token(RP);
}


void Expression::compileSorting() {
    parseSortList();
    jj_consume_token(0);
}


void Expression::parseSortList() {/*@bgen(jjtree) SORTLIST */
  SimpleNode *jjtn000 = new SimpleNode(JJTSORTLIST);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);



                               
/*@egen*/

    try {
      parseSortBy();
      while (!hasError) {
        switch (jj_nt->kind) {
        case COMMA:{
          ;
          break;
          }
        default:
          jj_la1[57] = jj_gen;
          goto end_label_14;
        }
        jj_consume_token(COMMA);
        parseSortBy();
      }
      end_label_14: ;
    } catch (...) {      
        
        if (jjtc000) {
          jjtree.clearNodeScope(jjtn000);
          jjtc000 = false;
        } else {
          jjtree.popNode();
        }
    
    
    
    
    
         
      
    }

    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      if (jjtree.nodeCreated()) {
       jjtreeCloseNodeScope(jjtn000);
      }
    }





     
  
}


void Expression::parseSortBy() {
    if (jj_2_7(2147483647)) {
      parseSortDescending();
    } else {
      switch (jj_nt->kind) {
      case IDENTIFIER_TOKEN:
      case IDENTIFIER_QUOTED_TOKEN:{
        parseSortAscending();
        break;
        }
      default:
        jj_la1[58] = jj_gen;
        jj_consume_token(-1);
        errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
      }
    }
}


void Expression::parseSortAscending() {/*@bgen(jjtree) SORTASCENDING */
  SimpleNode *jjtn000 = new SimpleNode(JJTSORTASCENDING);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);



                               
/*@egen*/

    try {
      parseAttribute();
      switch (jj_nt->kind) {
      case ASC:{
        jj_consume_token(ASC);
        break;
        }
      default:
        jj_la1[59] = jj_gen;
        ;
      }
    } catch (...) {      
        
        if (jjtc000) {
          jjtree.clearNodeScope(jjtn000);
          jjtc000 = false;
        } else {
          jjtree.popNode();
        }
    
    
    
    
    
         
      
    }

    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      if (jjtree.nodeCreated()) {
       jjtreeCloseNodeScope(jjtn000);
      }
    }





     
  
}


void Expression::parseSortDescending() {/*@bgen(jjtree) SORTDESCENDING */
  SimpleNode *jjtn000 = new SimpleNode(JJTSORTDESCENDING);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);



                               
/*@egen*/

    try {
      parseAttribute();
      jj_consume_token(DESC);
    } catch (...) {      
        
        if (jjtc000) {
          jjtree.clearNodeScope(jjtn000);
          jjtc000 = false;
        } else {
          jjtree.popNode();
        }
    
    
    
    
    
         
      
    }

    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      if (jjtree.nodeCreated()) {
       jjtreeCloseNodeScope(jjtn000);
      }
    }





     
  
}


  Expression::Expression(TokenManager *tokenManager){
    head = nullptr;
    ReInit(tokenManager);
}
Expression::~Expression()
{
  clear();
}

void Expression::ReInit(TokenManager* tokenManager){
    clear();
    errorHandler = new ErrorHandler();
    delete_eh = true;
    hasError = false;
    token_source = tokenManager;
    head = token = new Token();
    token->kind = 0;
    token->next = nullptr;
    jj_lookingAhead = false;
    jj_rescan = false;
    jj_done = false;
    jj_scanpos = jj_lastpos = nullptr;
    jj_gc = 0;
    jj_kind = -1;
    indent = 0;
    trace = false;
    token->next = jj_nt = token_source->getNextToken();
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 60; i++) jj_la1[i] = -1;
  }


void Expression::clear(){
  //Since token manager was generate from outside,
  //parser should not take care of deleting
  //if (token_source) delete token_source;
  if (delete_tokens && head) {
    Token *next, *t = head;
    while (t) {
      next = t->next;
      delete t;
      t = next;
    }
  }
  if (delete_eh) {
    delete errorHandler, errorHandler = nullptr;
    delete_eh = false;
  }
}


Token * Expression::jj_consume_token(int kind)  {
    Token *oldToken = token;
    if ((token = jj_nt)->next != nullptr) jj_nt = jj_nt->next;
    else jj_nt = jj_nt->next = token_source->getNextToken();
    if (token->kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < 7; i++) {
          JJCalls *c = &jj_2_rtns[i];
          while (c != nullptr) {
            if (c->gen < jj_gen) c->first = nullptr;
            c = c->next;
          }
        }
      }
      return token;
    }
    jj_nt = token;
    token = oldToken;
    jj_kind = kind;
    JJString image = kind >= 0 ? tokenImage[kind] : tokenImage[0];
    errorHandler->handleUnexpectedToken(kind, image.substr(1, image.size() - 2), getToken(1), this);
    hasError = true;
    return token;
  }


bool  Expression::jj_scan_token(int kind){
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos->next == nullptr) {
        jj_lastpos = jj_scanpos = jj_scanpos->next = token_source->getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos->next;
      }
    } else {
      jj_scanpos = jj_scanpos->next;
    }
    if (jj_rescan) {
      int i = 0; Token *tok = token;
      while (tok != nullptr && tok != jj_scanpos) { i++; tok = tok->next; }
      if (tok != nullptr) jj_add_error_token(kind, i);
    }
    if (jj_scanpos->kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) { return jj_done = true; }
    return false;
  }


/** Get the next Token. */

Token * Expression::getNextToken(){
    if ((token = jj_nt)->next != nullptr) jj_nt = jj_nt->next;
    else jj_nt = jj_nt->next = token_source->getNextToken();
    jj_gen++;
    return token;
  }

/** Get the specific Token. */

Token * Expression::getToken(int index){
    Token *t = token;
    for (int i = 0; i < index; i++) {
      if (t->next != nullptr) t = t->next;
      else t = t->next = token_source->getNextToken();
    }
    return t;
  }


  void Expression::jj_add_error_token(int kind, int pos)  {
  }


 void  Expression::parseError()   {
      std::cerr << "Parse error at : " << token->beginLine << ":" << token->beginColumn << " after token: " << addUnicodeEscapes(token->image) << " encountered: " << addUnicodeEscapes(getToken(1)->image) << std::endl;
   }


  bool Expression::trace_enabled()  {
    return trace;
  }


  void Expression::enable_tracing()  {
  }

  void Expression::disable_tracing()  {
  }


  void Expression::jj_rescan_token(){
    jj_rescan = true;
    for (int i = 0; i < 7; i++) {
      JJCalls *p = &jj_2_rtns[i];
      do {
        if (p->gen > jj_gen) {
          jj_la = p->arg; jj_lastpos = jj_scanpos = p->first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
          }
        }
        p = p->next;
      } while (p != nullptr);
    }
    jj_rescan = false;
  }


  void Expression::jj_save(int index, int xla){
    JJCalls *p = &jj_2_rtns[index];
    while (p->gen > jj_gen) {
      if (p->next == nullptr) { p = p->next = new JJCalls(); break; }
      p = p->next;
    }
    p->gen = jj_gen + xla - jj_la; p->first = token; p->arg = xla;
  }


/* JavaCC - OriginalChecksum=b228fe701389975b235457454071f3c1 (do not edit this line) */

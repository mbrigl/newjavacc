/* Generated By:JavaCC: Do not edit this line. ErrorHandler.h Version 8.0.0 */
/* JavaCCOptions:STATIC=true,SUPPORT_CLASS_VISIBILITY_PUBLIC=true,BUILD_PARSER=true,BUILD_TOKEN_MANAGER=true */
#ifndef JAVACC_ERROR_HANDLER_H
#define JAVACC_ERROR_HANDLER_H

#include <string>
#include "JavaCC.h"
#include "Token.h"


JJString addUnicodeEscapes(const JJString& str);

class SpecialToken;
class ErrorHandler {
  friend class SpecialTokenTokenManager;
  friend class SpecialToken;
public:
             ErrorHandler() { error_count = 0; }
    virtual ~ErrorHandler() {}
      
  // Called when the parser encounters a different token when expecting to consume a specific kind of token.
  // expectedKind  - token kind that the parser was trying to consume.
  // expectedToken - the image of the token - tokenImages[expectedKind].
  // actual        - the actual token that the parser got instead.
  virtual void handleUnexpectedToken(int expectedKind, const JJString& expectedImage, const JJString& expectedLabel, const Token* actual, SpecialToken* parser) {
    error_count++;
     JAVACC_CLOG 
       << JAVACC_WIDE(Expecting) << JJSPACE << addUnicodeEscapes(expectedLabel) << JAVACC_WIDE(:) << JJQUOTE << addUnicodeEscapes(expectedImage) << JJQUOTE
       << JJSPACE << JAVACC_WIDE(at) << JJSPACE << actual->beginLine() << JAVACC_WIDE(:) << actual->beginColumn() << JJSPACE 
       << JAVACC_WIDE(but got) << JJSPACE << JJQUOTE << addUnicodeEscapes(actual->image()) << JJQUOTE << std::endl;
  }
      
      
  // Called when the parser cannot continue parsing.
  // last         - the last token successfully parsed.
  // unexpected   - the token at which the error occurs.
  // production   - the production in which this error occurs.
  virtual void handleParseError(const Token* last, const Token* unexpected, const JJString& production, SpecialToken* parser) {
    error_count++;
    JAVACC_CLOG 
        << JAVACC_WIDE(Encountered:) << JJSPACE << JJQUOTE << addUnicodeEscapes(unexpected->image()) << JJQUOTE << JJSPACE 
        << JAVACC_WIDE(at) << JJSPACE << unexpected->beginLine() << JAVACC_WIDE(:) << unexpected->beginColumn() 
        << JAVACC_WIDE(while parsing:) << JJSPACE << production << std::endl;
  }
      
  virtual int getErrorCount() {
    return error_count;
  }
      
  virtual void handleOtherError(const JJString& message, SpecialToken* parser) {
    JAVACC_CLOG << JAVACC_WIDE(Error:) << JJSPACE  << message << std::endl;
  }

protected:
  int error_count;
      
};

class SpecialTokenTokenManager;
class TokenManagerErrorHandler {
  friend class SpecialTokenTokenManager;
public:
  virtual ~TokenManagerErrorHandler() {}
protected:
  int error_count;
    
public:
  // Returns a detailed message for the Error when it is thrown by the
  // token manager to indicate a lexical error.
  // Parameters :
  //    EOFSeen     : indicates if EOF caused the lexical error
  //    curLexState : lexical state in which this error occurred
  //    errorLine   : line number when the error occurred
  //    errorColumn : column number when the error occurred
  //    errorAfter  : prefix that was seen before this error occurred
  //    curchar     : the offending character
  //
  virtual void lexicalError(bool EOFSeen, int lexState, int errorLine, int errorColumn, JJString errorAfter, JJChar curChar, SpecialTokenTokenManager* tokenManager) {
    JAVACC_CLOG 
      << JAVACC_WIDE(Lexical error at)  << JJSPACE << errorLine << JAVACC_WIDE(:) << errorColumn << JAVACC_WIDE(.)
      << JAVACC_WIDE( Encountered:)  << JJSPACE << curChar <<JAVACC_WIDE( after:)  << JJSPACE << errorAfter << JAVACC_WIDE(.) << std::endl;
  }
      
  virtual void lexicalError(const JJString& errorMessage, SpecialTokenTokenManager* tokenManager) {
    JAVACC_CLOG << errorMessage << std::endl;
  }
};


#endif
/* JavaCC - OriginalChecksum=609cfb1063065ae25ee6e07965a877e4 (do not edit this line) */

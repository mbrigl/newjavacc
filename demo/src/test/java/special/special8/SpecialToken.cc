/* Generated By:JavaCC: Do not edit this line. SpecialToken.cc Version 8.0.0 */
#include "SpecialToken.h"
#include "TokenManagerError.h"
static unsigned int jj_la1_0[] = {
0x2000,};

  /** Constructor with user supplied TokenManager. */



void SpecialToken::Input() {
    JJEnter<std::function<void()>> jjenter([this]() {trace_call  ("Input"); });
    JJExit <std::function<void()>> jjexit ([this]() {trace_return("Input"); });
    try {

      if (!hasError) {
      while (!hasError) {
        if (!hasError) {
        jj_consume_token(Id);
        }
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case Id:{
          ;
          break;
          }
        default:
          jj_la1[0] = jj_gen;
          goto end_label_1;
        }
      }
      end_label_1: ;
      }
      if (!hasError) {
      jj_consume_token(0);
      }
    } catch(...) { }
}


  SpecialToken::SpecialToken(TokenManager* tokenManager){
    head = nullptr;
    ReInit(tokenManager);
}
SpecialToken::~SpecialToken()
{
  clear();
}

void SpecialToken::ReInit(TokenManager* tokenManager){
    clear();
    errorHandler = new ErrorHandler();
    delete_eh = true;
    hasError = false;
    token_source = tokenManager;
    head = token = new DefaultToken;
    jj_lookingAhead = false;
    jj_rescan = false;
    jj_done = false;
    jj_scanpos = jj_lastpos = nullptr;
    jj_gc = 0;
    jj_kind = -1;
    indent = 0;
    trace = true;
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 1; i++) jj_la1[i] = -1;
  }


void SpecialToken::clear(){
  //Since token manager was generate from outside,
  //parser should not take care of deleting
  //if (token_source) delete token_source;
  if (delete_tokens && head) {
    Token* next;
    Token* t = head;
    while (t) {
      next = t->next();
      delete t;
      t = next;
    }
  }
  if (delete_eh) {
    delete errorHandler, errorHandler = nullptr;
    delete_eh = false;
  }
}


Token*  SpecialToken::jj_consume_token(int kind)  {
    Token* oldToken;
    if ((oldToken = token)->next() != nullptr) token = token->next();
    else token = token->next() = token_source->getNextToken();
    jj_ntk = -1;
    if (token->kind() == kind) {
      jj_gen++;
      trace_token(token, "");
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    const JJString& image = kind >= 0 ? tokenImages[kind] : tokenImages[0];
    const JJString& label = kind >= 0 ? tokenLabels[kind] : tokenLabels[0];
    errorHandler->handleUnexpectedToken(kind, image, label, getToken(1), this);
    hasError = true;
    return token;
  }


/** Get the next Token. */

Token*  SpecialToken::getNextToken(){
    if (token->next() != nullptr) token = token->next();
    else token = token->next() = token_source->getNextToken();
    jj_ntk = -1;
    jj_gen++;
      trace_token(token, " (in getNextToken)");
    return token;
  }

/** Get the specific Token. */

Token*  SpecialToken::getToken(int index){
    Token* t = token;
    for (int i = 0; i < index; i++) {
      if (t->next() != nullptr) t = t->next();
      else t = t->next() = token_source->getNextToken();
    }
    return t;
  }


int SpecialToken::jj_ntk_f(){
    if ((jj_nt=token->next()) == nullptr)
      return (jj_ntk = (token->next()=token_source->getNextToken())->kind());
    else
      return (jj_ntk = jj_nt->kind());
  }


 void  SpecialToken::parseError()   {
      JAVACC_CERR << JAVACC_WIDE(Parse error at : ) << token->beginLine() << JAVACC_WIDE(:) << token->beginColumn() << JAVACC_WIDE( after token: ) << addUnicodeEscapes(token->image()) << JAVACC_WIDE( encountered: ) << addUnicodeEscapes(getToken(1)->image()) << std::endl;
   }


  bool SpecialToken::trace_enabled()  {
    return trace;
  }


  void SpecialToken::enable_tracing(){
    trace = true;
}


  void SpecialToken::disable_tracing(){
    trace = false;
}


  void SpecialToken::trace_call(const char *s)  {
    if (trace_enabled()) {
      for (int no = 0; no < indent; no++) { std::clog << " "; }
      std::clog << "Call:   " << s << std::endl;
    }
    indent += 2;
  }


  void SpecialToken::trace_return(const char *s)  {
    indent -= 2;
    if (trace_enabled()) {
      for (int no = 0; no < indent; no++) { std::clog << " "; }
      std::clog << "Return: " << s << std::endl;
    }
  }


  void SpecialToken::trace_token(const Token* token, const char* where)  {
    if (trace_enabled()) {
      for (int no = 0; no < indent; no++) { JAVACC_CLOG << JJSPACE; }
      JAVACC_CLOG << JAVACC_WIDE(Consumed token: ) << addUnicodeEscapes(tokenLabels[token->kind()]) << JJCOMMA << JJSPACE << JJQUOTE << addUnicodeEscapes(token->image()) << JJQUOTE;
      JAVACC_CLOG << JJSPACE << JAVACC_WIDE(at) << JJSPACE << token->beginLine() << JAVACC_WIDE(:) << token->beginColumn() << *where << std::endl;
    }
  }


  void SpecialToken::trace_scan(const Token* token, int t2)  {
    if (trace_enabled()) {
      for (int no = 0; no < indent; no++) { JAVACC_CLOG << JJSPACE; }
      JAVACC_CLOG << JAVACC_WIDE(Visited  token: ) << addUnicodeEscapes(tokenLabels[token->kind()]) << JJCOMMA << JJSPACE << JJQUOTE << addUnicodeEscapes(token->image()) << JJQUOTE;
      JAVACC_CLOG << JJSPACE << JAVACC_WIDE(at) << JJSPACE << token->beginLine() << JAVACC_WIDE(:) << token->beginColumn() << JJCOMMA << JJSPACE << JAVACC_WIDE(Expected token: ) << addUnicodeEscapes(tokenLabels[t2]) << std::endl;
    }
  }


/* JavaCC - OriginalChecksum=beb950661a0725d1ded0d2d6f5ce9dfd (do not edit this line) */

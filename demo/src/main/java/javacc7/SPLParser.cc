/* Generated By:JavaCC: Do not edit this line. SPLParser.cc Version 8.0.0 */
#include "SPLParser.h"
#include "SPLParserTree.h"

#include "TokenMgrError.h"
  unsigned int jj_la1_0[] = {
0xa00003c0,0xa00003c0,0xc0,0xb8000100,0x800,0x1000,0x2000,0x4000,0x8000,0x30000,0x30000,0x3c0000,0x3c0000,0xc00000,0xc00000,0x7000000,0x7000000,0xb8000100,0xa0000100,0x80000100,0x80000000,0x200,0xa0000100,0xa0000300,0x0,0x0,};
  unsigned int jj_la1_1[] = {
0x3d5,0x3d5,0x0,0x201,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x201,0x201,0x1,0x1,0x0,0x3d5,0x3d5,0x20,0x180,};

  /** Constructor with user supplied TokenManager. */




void SPLParser::CompilationUnit() {
    JJEnter<std::function<void()>> jjenter([this]() {trace_call  ("CompilationUnit"); });
    JJExit <std::function<void()>> jjexit ([this]() {trace_return("CompilationUnit"); });
    try {

   string name;/*@bgen(jjtree) CompilationUnit */
  ASTCompilationUnit *jjtn000 = new ASTCompilationUnit(JJTCOMPILATIONUNIT);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000->jjtSetFirstToken(getToken(1));




                                         
/*@egen*/      
                

      try {
        while (!hasError) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case INT:
          case BOOL:
          case INTEGER_LITERAL:
          case 9:
          case 29:
          case 31:
          case 32:
          case 34:
          case 36:
          case 38:
          case 39:
          case 40:
          case IDENTIFIER:{
            ;
            break;
            }
          default:
            jj_la1[0] = jj_gen;
            goto end_label_1;
          }
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case INT:
          case BOOL:{
            VarDeclaration();
            jj_consume_token(9);
            break;
            }
          case INTEGER_LITERAL:
          case 9:
          case 29:
          case 31:
          case 32:
          case 34:
          case 36:
          case 38:
          case 39:
          case 40:
          case IDENTIFIER:{
            Statement();
            break;
            }
          default:
            jj_la1[1] = jj_gen;
            jj_consume_token(-1);
            errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
          }
        }
        end_label_1: ;
        jj_consume_token(0);
      } catch (...) {      
           
           if (jjtc000) {
             jjtree.clearNodeScope(jjtn000);
             jjtc000 = false;
           } else {
             jjtree.popNode();
           }
      
      
      
      
      
            
         
      }

     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtn000->jjtSetLastToken(getToken(0));
     }



      
   
    } catch(...) { }
}


void SPLParser::VarDeclaration() {
    JJEnter<std::function<void()>> jjenter([this]() {trace_call  ("VarDeclaration"); });
    JJExit <std::function<void()>> jjexit ([this]() {trace_return("VarDeclaration"); });
    try {
 Token* t;/*@bgen(jjtree) VarDeclaration */
  ASTVarDeclaration *jjtn000 = new ASTVarDeclaration(JJTVARDECLARATION);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000->jjtSetFirstToken(getToken(1));



                                         
/*@egen*/   
      try {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case BOOL:{
          jj_consume_token(BOOL);
 jjtn000->type = BOOL;                       
          break;
          }
        case INT:{
          jj_consume_token(INT);
 jjtn000->type = INT;                      
          break;
          }
        default:
          jj_la1[2] = jj_gen;
          jj_consume_token(-1);
          errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
        }
        
          t
             = jj_consume_token(IDENTIFIER);

    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000->jjtSetLastToken(getToken(0));


                                          
  
 jjtn000->name = t->image;                           
      } catch (...) {      
          
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
      
      
      
      
      
           
        
      }

    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000->jjtSetLastToken(getToken(0));
    }



     
  
    } catch(...) { }
}


void SPLParser::Expression() {
    JJEnter<std::function<void()>> jjenter([this]() {trace_call  ("Expression"); });
    JJExit <std::function<void()>> jjexit ([this]() {trace_return("Expression"); });
    try {

      if (jj_2_1(2147483647)) {
        Assignment();
      } else {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case INTEGER_LITERAL:
        case 27:
        case 28:
        case 29:
        case 31:
        case 32:
        case IDENTIFIER:{
          ConditionalOrExpression();
          break;
          }
        default:
          jj_la1[3] = jj_gen;
          jj_consume_token(-1);
          errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
        }
      }
    } catch(...) { }
}


void SPLParser::Assignment() {
    JJEnter<std::function<void()>> jjenter([this]() {trace_call  ("Assignment"); });
    JJExit <std::function<void()>> jjexit ([this]() {trace_return("Assignment"); });
    try {
/*@bgen(jjtree) #Assignment( 2) */
  ASTAssignment *jjtn000 = new ASTAssignment(JJTASSIGNMENT);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000->jjtSetFirstToken(getToken(1));



                                         
/*@egen*/

      try {
        PrimaryExpression();
        jj_consume_token(10);
        Expression();
      } catch (...) {      
          
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
      
      
      
      
      
           
        
      }

    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000,  2);
      jjtn000->jjtSetLastToken(getToken(0));
    }



     
  
    } catch(...) { }
}


void SPLParser::ConditionalOrExpression() {
    JJEnter<std::function<void()>> jjenter([this]() {trace_call  ("ConditionalOrExpression"); });
    JJExit <std::function<void()>> jjexit ([this]() {trace_return("ConditionalOrExpression"); });
    try {

      ConditionalAndExpression();
      while (!hasError) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 11:{
          ;
          break;
          }
        default:
          jj_la1[4] = jj_gen;
          goto end_label_2;
        }
        jj_consume_token(11);

           ASTOrNode *jjtn001 = new ASTOrNode(JJTORNODE);
           bool jjtc001 = true;
           jjtree.openNodeScope(jjtn001);
           jjtn001->jjtSetFirstToken(getToken(1));



                                                  
         
        try {
          ConditionalAndExpression();
        } catch (...) {      
                   
                   if (jjtc001) {
                     jjtree.clearNodeScope(jjtn001);
                     jjtc001 = false;
                   } else {
                     jjtree.popNode();
                   }
        
        
        
        
        
                    
                 
        }

           if (jjtc001) {
             jjtree.closeNodeScope(jjtn001,  2);
             jjtn001->jjtSetLastToken(getToken(0));
           }



            
         
      }
      end_label_2: ;
    } catch(...) { }
}


void SPLParser::ConditionalAndExpression() {
    JJEnter<std::function<void()>> jjenter([this]() {trace_call  ("ConditionalAndExpression"); });
    JJExit <std::function<void()>> jjexit ([this]() {trace_return("ConditionalAndExpression"); });
    try {

      InclusiveOrExpression();
      while (!hasError) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 12:{
          ;
          break;
          }
        default:
          jj_la1[5] = jj_gen;
          goto end_label_3;
        }
        jj_consume_token(12);

           ASTAndNode *jjtn001 = new ASTAndNode(JJTANDNODE);
           bool jjtc001 = true;
           jjtree.openNodeScope(jjtn001);
           jjtn001->jjtSetFirstToken(getToken(1));



                                                  
         
        try {
          InclusiveOrExpression();
        } catch (...) {      
                   
                   if (jjtc001) {
                     jjtree.clearNodeScope(jjtn001);
                     jjtc001 = false;
                   } else {
                     jjtree.popNode();
                   }
        
        
        
        
        
                    
                 
        }

           if (jjtc001) {
             jjtree.closeNodeScope(jjtn001,  2);
             jjtn001->jjtSetLastToken(getToken(0));
           }



            
         
      }
      end_label_3: ;
    } catch(...) { }
}


void SPLParser::InclusiveOrExpression() {
    JJEnter<std::function<void()>> jjenter([this]() {trace_call  ("InclusiveOrExpression"); });
    JJExit <std::function<void()>> jjexit ([this]() {trace_return("InclusiveOrExpression"); });
    try {

      ExclusiveOrExpression();
      while (!hasError) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 13:{
          ;
          break;
          }
        default:
          jj_la1[6] = jj_gen;
          goto end_label_4;
        }
        jj_consume_token(13);

          ASTBitwiseOrNode *jjtn001 = new ASTBitwiseOrNode(JJTBITWISEORNODE);
          bool jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
          jjtn001->jjtSetFirstToken(getToken(1));



                                                 
        
        try {
          ExclusiveOrExpression();
        } catch (...) {      
                  
                  if (jjtc001) {
                    jjtree.clearNodeScope(jjtn001);
                    jjtc001 = false;
                  } else {
                    jjtree.popNode();
                  }
        
        
        
        
        
                   
                
        }

          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
            jjtn001->jjtSetLastToken(getToken(0));
          }



           
        
      }
      end_label_4: ;
    } catch(...) { }
}


void SPLParser::ExclusiveOrExpression() {
    JJEnter<std::function<void()>> jjenter([this]() {trace_call  ("ExclusiveOrExpression"); });
    JJExit <std::function<void()>> jjexit ([this]() {trace_return("ExclusiveOrExpression"); });
    try {

      AndExpression();
      while (!hasError) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 14:{
          ;
          break;
          }
        default:
          jj_la1[7] = jj_gen;
          goto end_label_5;
        }
        jj_consume_token(14);

          ASTBitwiseXorNode *jjtn001 = new ASTBitwiseXorNode(JJTBITWISEXORNODE);
          bool jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
          jjtn001->jjtSetFirstToken(getToken(1));



                                                 
        
        try {
          AndExpression();
        } catch (...) {      
                  
                  if (jjtc001) {
                    jjtree.clearNodeScope(jjtn001);
                    jjtc001 = false;
                  } else {
                    jjtree.popNode();
                  }
        
        
        
        
        
                   
                
        }

          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
            jjtn001->jjtSetLastToken(getToken(0));
          }



           
        
      }
      end_label_5: ;
    } catch(...) { }
}


void SPLParser::AndExpression() {
    JJEnter<std::function<void()>> jjenter([this]() {trace_call  ("AndExpression"); });
    JJExit <std::function<void()>> jjexit ([this]() {trace_return("AndExpression"); });
    try {

      EqualityExpression();
      while (!hasError) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 15:{
          ;
          break;
          }
        default:
          jj_la1[8] = jj_gen;
          goto end_label_6;
        }
        jj_consume_token(15);

          ASTBitwiseAndNode *jjtn001 = new ASTBitwiseAndNode(JJTBITWISEANDNODE);
          bool jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
          jjtn001->jjtSetFirstToken(getToken(1));



                                                 
        
        try {
          EqualityExpression();
        } catch (...) {      
                  
                  if (jjtc001) {
                    jjtree.clearNodeScope(jjtn001);
                    jjtc001 = false;
                  } else {
                    jjtree.popNode();
                  }
        
        
        
        
        
                   
                
        }

          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
            jjtn001->jjtSetLastToken(getToken(0));
          }



           
        
      }
      end_label_6: ;
    } catch(...) { }
}


void SPLParser::EqualityExpression() {
    JJEnter<std::function<void()>> jjenter([this]() {trace_call  ("EqualityExpression"); });
    JJExit <std::function<void()>> jjexit ([this]() {trace_return("EqualityExpression"); });
    try {

      RelationalExpression();
      while (!hasError) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 16:
        case 17:{
          ;
          break;
          }
        default:
          jj_la1[9] = jj_gen;
          goto end_label_7;
        }
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 16:{
          jj_consume_token(16);

            ASTEQNode *jjtn001 = new ASTEQNode(JJTEQNODE);
            bool jjtc001 = true;
            jjtree.openNodeScope(jjtn001);
            jjtn001->jjtSetFirstToken(getToken(1));



                                                   
          
          try {
            RelationalExpression();
          } catch (...) {      
                      
                      if (jjtc001) {
                        jjtree.clearNodeScope(jjtn001);
                        jjtc001 = false;
                      } else {
                        jjtree.popNode();
                      }
          
          
          
          
          
                       
                    
          }

            if (jjtc001) {
              jjtree.closeNodeScope(jjtn001,  2);
              jjtn001->jjtSetLastToken(getToken(0));
            }



             
          
          break;
          }
        case 17:{
          jj_consume_token(17);

            ASTNENode *jjtn002 = new ASTNENode(JJTNENODE);
            bool jjtc002 = true;
            jjtree.openNodeScope(jjtn002);
            jjtn002->jjtSetFirstToken(getToken(1));



                                                   
          
          try {
            RelationalExpression();
          } catch (...) {      
                      
                      if (jjtc002) {
                        jjtree.clearNodeScope(jjtn002);
                        jjtc002 = false;
                      } else {
                        jjtree.popNode();
                      }
          
          
          
          
          
                       
                    
          }

            if (jjtc002) {
              jjtree.closeNodeScope(jjtn002,  2);
              jjtn002->jjtSetLastToken(getToken(0));
            }



             
          
          break;
          }
        default:
          jj_la1[10] = jj_gen;
          jj_consume_token(-1);
          errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
        }
      }
      end_label_7: ;
    } catch(...) { }
}


void SPLParser::RelationalExpression() {
    JJEnter<std::function<void()>> jjenter([this]() {trace_call  ("RelationalExpression"); });
    JJExit <std::function<void()>> jjexit ([this]() {trace_return("RelationalExpression"); });
    try {

      AdditiveExpression();
      while (!hasError) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 18:
        case 19:
        case 20:
        case 21:{
          ;
          break;
          }
        default:
          jj_la1[11] = jj_gen;
          goto end_label_8;
        }
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 18:{
          jj_consume_token(18);

          ASTLTNode *jjtn001 = new ASTLTNode(JJTLTNODE);
          bool jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
          jjtn001->jjtSetFirstToken(getToken(1));



                                                 
        
          try {
            AdditiveExpression();
          } catch (...) {      
                    
                    if (jjtc001) {
                      jjtree.clearNodeScope(jjtn001);
                      jjtc001 = false;
                    } else {
                      jjtree.popNode();
                    }
          
          
          
          
          
                     
                  
          }

          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
            jjtn001->jjtSetLastToken(getToken(0));
          }



           
        
          break;
          }
        case 19:{
          jj_consume_token(19);

          ASTGTNode *jjtn002 = new ASTGTNode(JJTGTNODE);
          bool jjtc002 = true;
          jjtree.openNodeScope(jjtn002);
          jjtn002->jjtSetFirstToken(getToken(1));



                                                 
        
          try {
            AdditiveExpression();
          } catch (...) {      
                    
                    if (jjtc002) {
                      jjtree.clearNodeScope(jjtn002);
                      jjtc002 = false;
                    } else {
                      jjtree.popNode();
                    }
          
          
          
          
          
                     
                  
          }

          if (jjtc002) {
            jjtree.closeNodeScope(jjtn002,  2);
            jjtn002->jjtSetLastToken(getToken(0));
          }



           
        
          break;
          }
        case 20:{
          jj_consume_token(20);

           ASTLENode *jjtn003 = new ASTLENode(JJTLENODE);
           bool jjtc003 = true;
           jjtree.openNodeScope(jjtn003);
           jjtn003->jjtSetFirstToken(getToken(1));



                                                  
         
          try {
            AdditiveExpression();
          } catch (...) {      
                     
                     if (jjtc003) {
                       jjtree.clearNodeScope(jjtn003);
                       jjtc003 = false;
                     } else {
                       jjtree.popNode();
                     }
          
          
          
          
          
                      
                   
          }

           if (jjtc003) {
             jjtree.closeNodeScope(jjtn003,  2);
             jjtn003->jjtSetLastToken(getToken(0));
           }



            
         
          break;
          }
        case 21:{
          jj_consume_token(21);

           ASTGENode *jjtn004 = new ASTGENode(JJTGENODE);
           bool jjtc004 = true;
           jjtree.openNodeScope(jjtn004);
           jjtn004->jjtSetFirstToken(getToken(1));



                                                  
         
          try {
            AdditiveExpression();
          } catch (...) {      
                     
                     if (jjtc004) {
                       jjtree.clearNodeScope(jjtn004);
                       jjtc004 = false;
                     } else {
                       jjtree.popNode();
                     }
          
          
          
          
          
                      
                   
          }

           if (jjtc004) {
             jjtree.closeNodeScope(jjtn004,  2);
             jjtn004->jjtSetLastToken(getToken(0));
           }



            
         
          break;
          }
        default:
          jj_la1[12] = jj_gen;
          jj_consume_token(-1);
          errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
        }
      }
      end_label_8: ;
    } catch(...) { }
}


void SPLParser::AdditiveExpression() {
    JJEnter<std::function<void()>> jjenter([this]() {trace_call  ("AdditiveExpression"); });
    JJExit <std::function<void()>> jjexit ([this]() {trace_return("AdditiveExpression"); });
    try {

      MultiplicativeExpression();
      while (!hasError) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 22:
        case 23:{
          ;
          break;
          }
        default:
          jj_la1[13] = jj_gen;
          goto end_label_9;
        }
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 22:{
          jj_consume_token(22);

          ASTAddNode *jjtn001 = new ASTAddNode(JJTADDNODE);
          bool jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
          jjtn001->jjtSetFirstToken(getToken(1));



                                                 
        
          try {
            MultiplicativeExpression();
          } catch (...) {      
                    
                    if (jjtc001) {
                      jjtree.clearNodeScope(jjtn001);
                      jjtc001 = false;
                    } else {
                      jjtree.popNode();
                    }
          
          
          
          
          
                     
                  
          }

          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
            jjtn001->jjtSetLastToken(getToken(0));
          }



           
        
          break;
          }
        case 23:{
          jj_consume_token(23);

          ASTSubtractNode *jjtn002 = new ASTSubtractNode(JJTSUBTRACTNODE);
          bool jjtc002 = true;
          jjtree.openNodeScope(jjtn002);
          jjtn002->jjtSetFirstToken(getToken(1));



                                                 
        
          try {
            MultiplicativeExpression();
          } catch (...) {      
                    
                    if (jjtc002) {
                      jjtree.clearNodeScope(jjtn002);
                      jjtc002 = false;
                    } else {
                      jjtree.popNode();
                    }
          
          
          
          
          
                     
                  
          }

          if (jjtc002) {
            jjtree.closeNodeScope(jjtn002,  2);
            jjtn002->jjtSetLastToken(getToken(0));
          }



           
        
          break;
          }
        default:
          jj_la1[14] = jj_gen;
          jj_consume_token(-1);
          errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
        }
      }
      end_label_9: ;
    } catch(...) { }
}


void SPLParser::MultiplicativeExpression() {
    JJEnter<std::function<void()>> jjenter([this]() {trace_call  ("MultiplicativeExpression"); });
    JJExit <std::function<void()>> jjexit ([this]() {trace_return("MultiplicativeExpression"); });
    try {

      UnaryExpression();
      while (!hasError) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 24:
        case 25:
        case 26:{
          ;
          break;
          }
        default:
          jj_la1[15] = jj_gen;
          goto end_label_10;
        }
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 24:{
          jj_consume_token(24);

          ASTMulNode *jjtn001 = new ASTMulNode(JJTMULNODE);
          bool jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
          jjtn001->jjtSetFirstToken(getToken(1));



                                                 
        
          try {
            UnaryExpression();
          } catch (...) {      
                    
                    if (jjtc001) {
                      jjtree.clearNodeScope(jjtn001);
                      jjtc001 = false;
                    } else {
                      jjtree.popNode();
                    }
          
          
          
          
          
                     
                  
          }

          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
            jjtn001->jjtSetLastToken(getToken(0));
          }



           
        
          break;
          }
        case 25:{
          jj_consume_token(25);

          ASTDivNode *jjtn002 = new ASTDivNode(JJTDIVNODE);
          bool jjtc002 = true;
          jjtree.openNodeScope(jjtn002);
          jjtn002->jjtSetFirstToken(getToken(1));



                                                 
        
          try {
            UnaryExpression();
          } catch (...) {      
                    
                    if (jjtc002) {
                      jjtree.clearNodeScope(jjtn002);
                      jjtc002 = false;
                    } else {
                      jjtree.popNode();
                    }
          
          
          
          
          
                     
                  
          }

          if (jjtc002) {
            jjtree.closeNodeScope(jjtn002,  2);
            jjtn002->jjtSetLastToken(getToken(0));
          }



           
        
          break;
          }
        case 26:{
          jj_consume_token(26);

          ASTModNode *jjtn003 = new ASTModNode(JJTMODNODE);
          bool jjtc003 = true;
          jjtree.openNodeScope(jjtn003);
          jjtn003->jjtSetFirstToken(getToken(1));



                                                 
        
          try {
            UnaryExpression();
          } catch (...) {      
                    
                    if (jjtc003) {
                      jjtree.clearNodeScope(jjtn003);
                      jjtc003 = false;
                    } else {
                      jjtree.popNode();
                    }
          
          
          
          
          
                     
                  
          }

          if (jjtc003) {
            jjtree.closeNodeScope(jjtn003,  2);
            jjtn003->jjtSetLastToken(getToken(0));
          }



           
        
          break;
          }
        default:
          jj_la1[16] = jj_gen;
          jj_consume_token(-1);
          errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
        }
      }
      end_label_10: ;
    } catch(...) { }
}


void SPLParser::UnaryExpression() {
    JJEnter<std::function<void()>> jjenter([this]() {trace_call  ("UnaryExpression"); });
    JJExit <std::function<void()>> jjexit ([this]() {trace_return("UnaryExpression"); });
    try {

      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 27:{
        jj_consume_token(27);

        ASTBitwiseComplNode *jjtn001 = new ASTBitwiseComplNode(JJTBITWISECOMPLNODE);
        bool jjtc001 = true;
        jjtree.openNodeScope(jjtn001);
        jjtn001->jjtSetFirstToken(getToken(1));



                                               
      
        try {
          UnaryExpression();
        } catch (...) {      
                
                if (jjtc001) {
                  jjtree.clearNodeScope(jjtn001);
                  jjtc001 = false;
                } else {
                  jjtree.popNode();
                }
        
        
        
        
        
                 
              
        }

        if (jjtc001) {
          jjtree.closeNodeScope(jjtn001,  1);
          jjtn001->jjtSetLastToken(getToken(0));
        }



         
      
        break;
        }
      case 28:{
        jj_consume_token(28);

        ASTNotNode *jjtn002 = new ASTNotNode(JJTNOTNODE);
        bool jjtc002 = true;
        jjtree.openNodeScope(jjtn002);
        jjtn002->jjtSetFirstToken(getToken(1));



                                               
      
        try {
          UnaryExpression();
        } catch (...) {      
                
                if (jjtc002) {
                  jjtree.clearNodeScope(jjtn002);
                  jjtc002 = false;
                } else {
                  jjtree.popNode();
                }
        
        
        
        
        
                 
              
        }

        if (jjtc002) {
          jjtree.closeNodeScope(jjtn002,  1);
          jjtn002->jjtSetLastToken(getToken(0));
        }



         
      
        break;
        }
      case INTEGER_LITERAL:
      case 29:
      case 31:
      case 32:
      case IDENTIFIER:{
        PrimaryExpression();
        break;
        }
      default:
        jj_la1[17] = jj_gen;
        jj_consume_token(-1);
        errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
      }
    } catch(...) { }
}


void SPLParser::PrimaryExpression() {
    JJEnter<std::function<void()>> jjenter([this]() {trace_call  ("PrimaryExpression"); });
    JJExit <std::function<void()>> jjexit ([this]() {trace_return("PrimaryExpression"); });
    try {

   string name;
               
                

      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case INTEGER_LITERAL:
      case 31:
      case 32:{
        Literal();
        break;
        }
      case IDENTIFIER:{
        Id();
        break;
        }
      case 29:{
        jj_consume_token(29);
        Expression();
        jj_consume_token(30);
        break;
        }
      default:
        jj_la1[18] = jj_gen;
        jj_consume_token(-1);
        errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
      }
    } catch(...) { }
}


void SPLParser::Id() {
    JJEnter<std::function<void()>> jjenter([this]() {trace_call  ("Id"); });
    JJExit <std::function<void()>> jjexit ([this]() {trace_return("Id"); });
    try {

   Token* t;/*@bgen(jjtree) Id */
  ASTId *jjtn000 = new ASTId(JJTID);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000->jjtSetFirstToken(getToken(1));




                                         
/*@egen*/   
             

      try {
        
        /*@egen*/
           t  = jj_consume_token(IDENTIFIER);

                       jjtree.closeNodeScope(jjtn000, true);
                       jjtc000 = false;
                       jjtn000->jjtSetLastToken(getToken(0));


                                                             
                     
 jjtn000->name = t->image;                           
      } catch (...) {      
           
           if (jjtc000) {
             jjtree.clearNodeScope(jjtn000);
             jjtc000 = false;
           } else {
             jjtree.popNode();
           }
      
      
      
      
      
            
         
      }

     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtn000->jjtSetLastToken(getToken(0));
     }



      
   
    } catch(...) { }
}


void SPLParser::Literal() {
    JJEnter<std::function<void()>> jjenter([this]() {trace_call  ("Literal"); });
    JJExit <std::function<void()>> jjexit ([this]() {trace_return("Literal"); });
    try {

   Token* t;
            
             

      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case INTEGER_LITERAL:{

   ASTIntConstNode *jjtn001 = new ASTIntConstNode(JJTINTCONSTNODE);
   bool jjtc001 = true;
   jjtree.openNodeScope(jjtn001);
   jjtn001->jjtSetFirstToken(getToken(1));



                                          
 
        try {
          
            t
               = jj_consume_token(INTEGER_LITERAL);

      jjtree.closeNodeScope(jjtn001, true);
      jjtc001 = false;
      jjtn001->jjtSetLastToken(getToken(0));


                                            
    

       jjtn001->val = stoi(t->image);
                                     
                                      
    
        } catch (...) {      
           
           if (jjtc001) {
             jjtree.clearNodeScope(jjtn001);
             jjtc001 = false;
           } else {
             jjtree.popNode();
           }
        
        
        
        
        
            
         
        }

   if (jjtc001) {
     jjtree.closeNodeScope(jjtn001, true);
     jjtn001->jjtSetLastToken(getToken(0));
   }



    
 
        break;
        }
      case 31:
      case 32:{
        BooleanLiteral();
        break;
        }
      default:
        jj_la1[19] = jj_gen;
        jj_consume_token(-1);
        errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
      }
    } catch(...) { }
}


void SPLParser::BooleanLiteral() {
    JJEnter<std::function<void()>> jjenter([this]() {trace_call  ("BooleanLiteral"); });
    JJExit <std::function<void()>> jjexit ([this]() {trace_return("BooleanLiteral"); });
    try {

      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 31:{

    ASTTrueNode *jjtn001 = new ASTTrueNode(JJTTRUENODE);
    bool jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    jjtn001->jjtSetFirstToken(getToken(1));



                                           
  
        try {
          jj_consume_token(31);
        } catch (...) {      
            
            if (jjtc001) {
              jjtree.clearNodeScope(jjtn001);
              jjtc001 = false;
            } else {
              jjtree.popNode();
            }
        
        
        
        
        
             
          
        }

    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, true);
      jjtn001->jjtSetLastToken(getToken(0));
    }



     
  
        break;
        }
      case 32:{

    ASTFalseNode *jjtn002 = new ASTFalseNode(JJTFALSENODE);
    bool jjtc002 = true;
    jjtree.openNodeScope(jjtn002);
    jjtn002->jjtSetFirstToken(getToken(1));



                                           
  
        try {
          jj_consume_token(32);
        } catch (...) {      
            
            if (jjtc002) {
              jjtree.clearNodeScope(jjtn002);
              jjtc002 = false;
            } else {
              jjtree.popNode();
            }
        
        
        
        
        
             
          
        }

    if (jjtc002) {
      jjtree.closeNodeScope(jjtn002, true);
      jjtn002->jjtSetLastToken(getToken(0));
    }



     
  
        break;
        }
      default:
        jj_la1[20] = jj_gen;
        jj_consume_token(-1);
        errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
      }
    } catch(...) { }
}


void SPLParser::Statement() {
    JJEnter<std::function<void()>> jjenter([this]() {trace_call  ("Statement"); });
    JJExit <std::function<void()>> jjexit ([this]() {trace_return("Statement"); });
    try {

      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 9:{
        jj_consume_token(9);
        break;
        }
      default:
        jj_la1[21] = jj_gen;
        if (jj_2_2(2)) {
          LabeledStatement();
        } else {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case 34:{
            Block();
            break;
            }
          case INTEGER_LITERAL:
          case 29:
          case 31:
          case 32:
          case IDENTIFIER:{
            StatementExpression();
            break;
            }
          case 36:{
            IfStatement();
            break;
            }
          case 38:{
            WhileStatement();
            break;
            }
          case 39:
          case 40:{
            IOStatement();
            break;
            }
          default:
            jj_la1[22] = jj_gen;
            jj_consume_token(-1);
            errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
          }
        }
      }
    } catch(...) { }
}


void SPLParser::LabeledStatement() {
    JJEnter<std::function<void()>> jjenter([this]() {trace_call  ("LabeledStatement"); });
    JJExit <std::function<void()>> jjexit ([this]() {trace_return("LabeledStatement"); });
    try {

      jj_consume_token(IDENTIFIER);
      jj_consume_token(33);
      Statement();
    } catch(...) { }
}


void SPLParser::Block() {
    JJEnter<std::function<void()>> jjenter([this]() {trace_call  ("Block"); });
    JJExit <std::function<void()>> jjexit ([this]() {trace_return("Block"); });
    try {

      jj_consume_token(34);
      while (!hasError) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case INTEGER_LITERAL:
        case 9:
        case 29:
        case 31:
        case 32:
        case 34:
        case 36:
        case 38:
        case 39:
        case 40:
        case IDENTIFIER:{
          ;
          break;
          }
        default:
          jj_la1[23] = jj_gen;
          goto end_label_11;
        }
        Statement();
      }
      end_label_11: ;
      jj_consume_token(35);
    } catch(...) { }
}


void SPLParser::StatementExpression() {
    JJEnter<std::function<void()>> jjenter([this]() {trace_call  ("StatementExpression"); });
    JJExit <std::function<void()>> jjexit ([this]() {trace_return("StatementExpression"); });
    try {

      Assignment();
      jj_consume_token(9);
    } catch(...) { }
}


void SPLParser::IfStatement() {
    JJEnter<std::function<void()>> jjenter([this]() {trace_call  ("IfStatement"); });
    JJExit <std::function<void()>> jjexit ([this]() {trace_return("IfStatement"); });
    try {

      jj_consume_token(36);
      jj_consume_token(29);
      Expression();
      jj_consume_token(30);
      Statement();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 37:{
        jj_consume_token(37);
        Statement();
        break;
        }
      default:
        jj_la1[24] = jj_gen;
        ;
      }
    } catch(...) { }
}


void SPLParser::WhileStatement() {
    JJEnter<std::function<void()>> jjenter([this]() {trace_call  ("WhileStatement"); });
    JJExit <std::function<void()>> jjexit ([this]() {trace_return("WhileStatement"); });
    try {

      jj_consume_token(38);
      jj_consume_token(29);
      Expression();
      jj_consume_token(30);
      Statement();
    } catch(...) { }
}


void SPLParser::IOStatement() {
    JJEnter<std::function<void()>> jjenter([this]() {trace_call  ("IOStatement"); });
    JJExit <std::function<void()>> jjexit ([this]() {trace_return("IOStatement"); });
    try {
 string name;              
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 39:{
        ReadStatement();
        break;
        }
      case 40:{
        WriteStatement();
        break;
        }
      default:
        jj_la1[25] = jj_gen;
        jj_consume_token(-1);
        errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
      }
    } catch(...) { }
}


void SPLParser::ReadStatement() {
    JJEnter<std::function<void()>> jjenter([this]() {trace_call  ("ReadStatement"); });
    JJExit <std::function<void()>> jjexit ([this]() {trace_return("ReadStatement"); });
    try {
 Token* t;/*@bgen(jjtree) ReadStatement */
  ASTReadStatement *jjtn000 = new ASTReadStatement(JJTREADSTATEMENT);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000->jjtSetFirstToken(getToken(1));



                                         
/*@egen*/   
      try {
        jj_consume_token(39);
         t    = jj_consume_token(IDENTIFIER);

     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
     jjtn000->jjtSetLastToken(getToken(0));


                                           
   
 jjtn000->name = t->image;                           
      } catch (...) {      
           
           if (jjtc000) {
             jjtree.clearNodeScope(jjtn000);
             jjtc000 = false;
           } else {
             jjtree.popNode();
           }
      
      
      
      
      
            
         
      }

     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtn000->jjtSetLastToken(getToken(0));
     }



      
   
    } catch(...) { }
}


void SPLParser::WriteStatement() {
    JJEnter<std::function<void()>> jjenter([this]() {trace_call  ("WriteStatement"); });
    JJExit <std::function<void()>> jjexit ([this]() {trace_return("WriteStatement"); });
    try {
 Token* t;/*@bgen(jjtree) WriteStatement */
  ASTWriteStatement *jjtn000 = new ASTWriteStatement(JJTWRITESTATEMENT);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000->jjtSetFirstToken(getToken(1));



                                         
/*@egen*/   
      try {
        jj_consume_token(40);
         t    = jj_consume_token(IDENTIFIER);

     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
     jjtn000->jjtSetLastToken(getToken(0));


                                           
   
 jjtn000->name = t->image;                           
      } catch (...) {      
           
           if (jjtc000) {
             jjtree.clearNodeScope(jjtn000);
             jjtc000 = false;
           } else {
             jjtree.popNode();
           }
      
      
      
      
      
            
         
      }

     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtn000->jjtSetLastToken(getToken(0));
     }



      
   
    } catch(...) { }
}


  SPLParser::SPLParser(TokenManager *tokenManager){
    head = nullptr;
    ReInit(tokenManager);
}
SPLParser::~SPLParser()
{
  clear();
}

void SPLParser::ReInit(TokenManager* tokenManager){
    clear();
    errorHandler = new ErrorHandler();
    delete_eh = true;
    hasError = false;
    token_source = tokenManager;
    head = token = new Token();
    token->kind = 0;
    token->next = nullptr;
    jj_lookingAhead = false;
    jj_rescan = false;
    jj_done = false;
    jj_scanpos = jj_lastpos = nullptr;
    jj_gc = 0;
    jj_kind = -1;
    indent = 0;
    trace = true;
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 26; i++) jj_la1[i] = -1;
  }


void SPLParser::clear(){
  //Since token manager was generate from outside,
  //parser should not take care of deleting
  //if (token_source) delete token_source;
  if (delete_tokens && head) {
    Token *next, *t = head;
    while (t) {
      next = t->next;
      delete t;
      t = next;
    }
  }
  if (delete_eh) {
    delete errorHandler, errorHandler = nullptr;
    delete_eh = false;
  }
}


Token * SPLParser::jj_consume_token(int kind)  {
    Token *oldToken;
    if ((oldToken = token)->next != nullptr) token = token->next;
    else token = token->next = token_source->getNextToken();
    jj_ntk = -1;
    if (token->kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < 2; i++) {
          JJCalls *c = &jj_2_rtns[i];
          while (c != nullptr) {
            if (c->gen < jj_gen) c->first = nullptr;
            c = c->next;
          }
        }
      }
      trace_token(token, "");
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    JJString image = kind >= 0 ? tokenImage[kind] : tokenImage[0];
    errorHandler->handleUnexpectedToken(kind, image.substr(1, image.size() - 2), getToken(1), this);
    hasError = true;
    return token;
  }


bool  SPLParser::jj_scan_token(int kind){
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos->next == nullptr) {
        jj_lastpos = jj_scanpos = jj_scanpos->next = token_source->getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos->next;
      }
    } else {
      jj_scanpos = jj_scanpos->next;
    }
    if (jj_rescan) {
      int i = 0; Token *tok = token;
      while (tok != nullptr && tok != jj_scanpos) { i++; tok = tok->next; }
      if (tok != nullptr) jj_add_error_token(kind, i);
    }
    if (jj_scanpos->kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) { return jj_done = true; }
    return false;
  }


/** Get the next Token. */

Token * SPLParser::getNextToken(){
    if (token->next != nullptr) token = token->next;
    else token = token->next = token_source->getNextToken();
    jj_ntk = -1;
    jj_gen++;
      trace_token(token, " (in getNextToken)");
    return token;
  }

/** Get the specific Token. */

Token * SPLParser::getToken(int index){
    Token *t = token;
    for (int i = 0; i < index; i++) {
      if (t->next != nullptr) t = t->next;
      else t = t->next = token_source->getNextToken();
    }
    return t;
  }


int SPLParser::jj_ntk_f(){
    if ((jj_nt=token->next) == nullptr)
      return (jj_ntk = (token->next=token_source->getNextToken())->kind);
    else
      return (jj_ntk = jj_nt->kind);
  }


  void SPLParser::jj_add_error_token(int kind, int pos)  {
  }


 void  SPLParser::parseError()   {
      std::cerr << "Parse error at : " << token->beginLine << ":" << token->beginColumn << " after token: " << addUnicodeEscapes(token->image) << " encountered: " << addUnicodeEscapes(getToken(1)->image) << std::endl;
   }


  bool SPLParser::trace_enabled()  {
    return trace;
  }


  void SPLParser::enable_tracing(){
    trace = true;
}


  void SPLParser::disable_tracing(){
    trace = false;
}


  void SPLParser::trace_call(const char *s)  {
    if (trace_enabled()) {
      for (int i = 0; i < indent; i++) { std::clog << " "; }
      std::clog << "Call:   " << s << std::endl;
    }
    indent = indent + 2;
  }


  void SPLParser::trace_return(const char *s)  {
    indent = indent - 2;
    if (trace_enabled()) {
      for (int i = 0; i < indent; i++) { std::clog << " "; }
      std::clog << "Return: " << s << std::endl;
    }
  }


  void SPLParser::trace_token(Token *t, const char *where)  {
    if (trace_enabled()) {
      for (int i = 0; i < indent; i++) { std::clog << " "; }
      std::clog << "Consumed token: <kind: " << t->kind << "(" << addUnicodeEscapes(tokenImage[t->kind]) << "), " << addUnicodeEscapes(t->image);
      std::clog << " at line " << t->beginLine << " column " << t->beginColumn << *where << std::endl;
    }
  }


  void SPLParser::trace_scan(Token *t1, int t2)  {
    if (trace_enabled()) {
      for (int i = 0; i < indent; i++) { std::clog << " "; }
      std::clog << "Visited token: <Kind: " << t1->kind << "(" << addUnicodeEscapes(tokenImage[t1->kind]) << "), " << addUnicodeEscapes(t1->image);
      std::clog << " at line " << t1->beginLine << " column " << t1->beginColumn << "> Expected token: " << addUnicodeEscapes(tokenImage[t2]) << std::endl;
    }
  }


  void SPLParser::jj_rescan_token(){
    jj_rescan = true;
    for (int i = 0; i < 2; i++) {
      JJCalls *p = &jj_2_rtns[i];
      do {
        if (p->gen > jj_gen) {
          jj_la = p->arg; jj_lastpos = jj_scanpos = p->first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
          }
        }
        p = p->next;
      } while (p != nullptr);
    }
    jj_rescan = false;
  }


  void SPLParser::jj_save(int index, int xla){
    JJCalls *p = &jj_2_rtns[index];
    while (p->gen > jj_gen) {
      if (p->next == nullptr) { p = p->next = new JJCalls(); break; }
      p = p->next;
    }
    p->gen = jj_gen + xla - jj_la; p->first = token; p->arg = xla;
  }


/* JavaCC - OriginalChecksum=be901ec9024f970cb84a7821e89d4fa7 (do not edit this line) */

/* Generated By:JavaCC: Do not edit this line. JavaCCParserTokenManager.java Version 8.0.0 */

public class JavaCCParserTokenManager  implements JavaCCParserConstants {

protected static boolean moveToNextChar() {
  try {
    curChar = input_stream.readChar();
  } catch(java.io.IOException e) {
    return false;
  }
  return true;
}



    /** Constructor. */
    public JavaCCParserTokenManager(JavaCharStream stream){

      if (input_stream != null)
        throw new TokenMgrError("ERROR: Second call to constructor of static lexer. You must use ReInit() to initialize the static variables.", TokenMgrError.STATIC_LEXER_ERROR);

    input_stream = stream;
  }

  /** Constructor. */
  public JavaCCParserTokenManager (JavaCharStream stream, int lexState){
    ReInit(stream);
    SwitchTo(lexState);
  }

  /** Reinitialise parser. */
  
  static public void ReInit(JavaCharStream stream)
  {

    jjmatchedPos = 0;
    curLexState = defaultLexState;
    input_stream = stream;
  }

  /** Reinitialise parser. */
  static public void ReInit(JavaCharStream stream, int lexState)
  
  {
    ReInit(stream);
    SwitchTo(lexState);
  }

  /** Switch to specified lex state. */
  public static void SwitchTo(int lexState) {
    curLexState = lexState;
  }

private static  int jjRunStringLiteralMatch() {
  int curPos = 0;
  int key = (int)curLexState << 16 | curChar;
  int startState = jjInitStates[curLexState];
  if (startAndSize.containsKey(key)) {
    int[] arr = startAndSize.get(key);
    int index = arr[0];
    for (int i = 0; i < arr[1]; i++) {
      int len = stringLiterals[index++];
      int ignoreCase = stringLiterals[index++];
      do {
        if (curChar != stringLiterals[index + curPos] &&
            (ignoreCase == 0 || curChar != stringLiterals[index + len + curPos])) break;
        if (++curPos == len) break;
        if (!moveToNextChar()) {
          --curPos;
          break;
        }
      } while(curPos < len);
      if (curPos == len) {
        jjmatchedKind = stringLiterals[index + len + (ignoreCase * len)];
        jjmatchedPos = curPos;
        startState = stringLiterals[index + len + (ignoreCase * len) + 1];
        if (!moveToNextChar()) {
          return curPos;
        }
        curPos++;
        break;
      } else {
        index += len + (ignoreCase * len) + 2;
        input_stream.backup(curPos + 1);
        curPos = 0;
        if (!moveToNextChar()) {
          assert(false);
        }
      }
    }
  } else {
  }
  return jjMoveNfa(startState, curPos);
}

private static   int[] stateSet = new int[55];
private static   int[] newStateSet = new int[55];
private static   long[] moved = new long[55];
private static  long moveIndex = 1L;

private static final int jjMoveNfa(int startState, int curPos) {

  if (startState < 0) {
    return curPos;
  }

  // We have a long array indexed by the NFA state number to roughly indicate
  // the input position so when the input reaches part Long.MAX_VALUE (which
  // should be extremely rare), we need to reset them all back to zero.
  if (++moveIndex == Long.MAX_VALUE) {
    for (int i = 0; i < 55; i++) moved[i] = 0L;
    moveIndex = 1L;
  }

  // We initialize the kind to MAX value so that when a match is found, we can
  // simply check if it's less than the current match and store it in that
  // case. This helps implement the 'first occurring' rule properly.
  int cnt = 0;
  stateSet[cnt++] = startState;
  moved[startState] = moveIndex;
 
  // Some NFA states have epsilon transitions (move on empty string). So we
  // just start with all of them. Note that the nextStates array already adds
  // the epsilon closure. Only the initial state needs to do this explicitly.
  for (int s : jjcompositeState[startState]) { 
    if (moved[s] != moveIndex) {
      stateSet[cnt++] = s;
      moved[s] = moveIndex;
    }
  }

  do {
    int newCnt = 0;
    int kind = Integer.MAX_VALUE;
    if (++moveIndex == Long.MAX_VALUE) {
      for (int i = 0; i < 55; i++) moved[i] = 0L;
      moveIndex = 1L;
    }

    int vectorIndex = curChar >> 6;
    long bitpattern = (1L << (curChar & 0x3f));
    do {
      int state = stateSet[--cnt];
      if ((jjChars[state][vectorIndex] & bitpattern) != 0L) {
        // Current input character can move this NFA state. So add all the
        // next states of the current states for use with the next input char.
        for (int newState : jjnextStateSet[state]) {
          if (moved[newState] != moveIndex) {
            // We add each state only once.
            newStateSet[newCnt++] = newState;
            moved[newState] = moveIndex;
          }
        }
        int newKind = jjmatchKinds[state];
        if (kind > newKind) {
          // It's a state so store the matched kind if it's smaller than
          // what's already matched.
          kind = newKind;
        }
      }
    } while (cnt > 0);

    if (kind != Integer.MAX_VALUE) {
      // We found a match. So remember the kind and position of the match.
      jjmatchedKind = kind;
      jjmatchedPos = curPos;
      // Reset the kind to max value so we can contine looking for a longer
      // match.
      kind = Integer.MAX_VALUE;
    }

    // Swap the current and next state sets.
    int[] tmp = stateSet;
    stateSet = newStateSet;
    newStateSet = tmp;
    // Reset the number of states.
    cnt = newCnt;
    if (newCnt == 0) {
      // There were no transitions from any of the current states on the
      // current input. So we are done.
      return curPos;
    }
    // Read the next character and try to continue running the NFA.
    if (!moveToNextChar()) {
      // EOF reached!
      return curPos;
    }
    ++curPos;
  } while (cnt > 0);

  assert(false) :
      "Interal error. Please submit a bug at: http://javacc.java.net.";
  return curPos;
}

private static  int defaultLexState = 0;
protected static  int curLexState = 0;
private static  int jjmatchedPos;
private static  int jjmatchedKind;
private static  StringBuilder jjimage = new StringBuilder();
private static StringBuilder image = jjimage;
private static int jjimageLen;
private static int lengthOfMatch;
protected static int curChar;
protected static  JavaCharStream input_stream;

public static boolean isToken(int kind) {
  return (jjtoToken[kind >> 6] & (1L << (kind & 0x3f))) != 0L;
}

public static final boolean isSkip(int kind) {
  return (jjtoSkip[kind >> 6] & (1L << (kind & 0x3f))) != 0L;
}

public static boolean isSpecial(int kind) {
  return (jjtoSpecial[kind >> 6] & (1L << (kind & 0x3f))) != 0L;
}

public static boolean isMore(int kind) {
  return (jjtoMore[kind >> 6] & (1L << (kind & 0x3f))) != 0L;
}

protected static  Token jjFillToken() {
  Token t;
  String curTokenImage;
  int beginLine;
  int endLine;
  int beginColumn;
  int endColumn;
  if (jjmatchedPos < 0) {
    if (image == null) {
      curTokenImage = "";
    } else {
      curTokenImage = image.toString();
    }
    beginLine = endLine = input_stream.getEndLine();
    beginColumn = endColumn = input_stream.getEndColumn();
  } else {
    String im = jjstrLiteralImages[jjmatchedKind];
    curTokenImage = (im == null) ? input_stream.GetImage() : im;
    beginLine = input_stream.getBeginLine();
    beginColumn = input_stream.getBeginColumn();
    endLine = input_stream.getEndLine();
    endColumn = input_stream.getEndColumn();
  }

   t = Token.newToken(jjmatchedKind);
   t.kind = jjmatchedKind;
   t.image = curTokenImage;

   t.beginLine = beginLine;
   t.endLine = endLine;
   t.beginColumn = beginColumn;
   t.endColumn = endColumn;

   return t;
}

/** Get the next Token. */
public static  Token getNextToken() {
  Token specialToken = null;
  Token matchedToken;
  int lastReadPosition = 0;

  EOFLoop:
  for (;;) {
    // First see if we have any input at all.
    try {
      curChar = input_stream.BeginToken();
    } catch(Exception e) {
      // No input. So return EOF token.
      jjmatchedKind = EOF;
      jjmatchedPos = -1;
      matchedToken = jjFillToken();
      matchedToken.specialToken = specialToken;
      return matchedToken;
    }

    // Set matched kind to a MAX VALUE to implement largest, first occuring rule
    // i.e., smallest kind value matched should be used.
    image = jjimage;
    image.setLength(0);
    jjimageLen = 0;

    MoreLoop: for (;;) {
      jjmatchedKind = Integer.MAX_VALUE;
      jjmatchedPos = 0;
      lastReadPosition = jjRunStringLiteralMatch();
      if (jjmatchedPos == 0 && jjmatchedKind > canMatchAnyChar[curLexState]) {
        jjmatchedKind = canMatchAnyChar[curLexState];
      }

      if (jjmatchedKind != Integer.MAX_VALUE) {
        // We have a match!
  
        // Put back any characters looked ahead.
        input_stream.backup(lastReadPosition - jjmatchedPos);
        if (isToken(jjmatchedKind)) {
          // Matched kind is a real TOKEN.
          matchedToken = jjFillToken();
          matchedToken.specialToken = specialToken;
          TokenLexicalActions(matchedToken);
          if (jjnewLexState[jjmatchedKind] != -1) {
            curLexState = jjnewLexState[jjmatchedKind];
          }
          return matchedToken;
        } else if (isSkip(jjmatchedKind) || isSpecial(jjmatchedKind)) {
          // Matched kind is a SKIP or SPECIAL_TOKEN.
          if (isSpecial(jjmatchedKind)) {
            matchedToken = jjFillToken();
            if (specialToken == null) {
              specialToken = matchedToken;
            } else {
              matchedToken.specialToken = specialToken;
              specialToken = (specialToken.next = matchedToken);
            }
            SkipLexicalActions(matchedToken);
          } else {
            SkipLexicalActions(null);
          }
          if (jjnewLexState[jjmatchedKind] != -1) {
            curLexState = jjnewLexState[jjmatchedKind];
          }
          continue EOFLoop;
        }
        // Here it's a MORE.
        MoreLexicalActions();
        if (jjnewLexState[jjmatchedKind] != -1) {
          curLexState = jjnewLexState[jjmatchedKind];
        }
        lastReadPosition = 0;
        jjmatchedKind = Integer.MAX_VALUE;
        try {
          curChar = input_stream.readChar();
          continue;
        }
        catch (java.io.IOException e1) { }
      }
      reportError(lastReadPosition);
    }
  }
}

protected static  void reportError(int lastReadPosition) {
  int error_line = input_stream.getEndLine();
  int error_column = input_stream.getEndColumn();
  String error_after = null;
  boolean EOFSeen = false;
  try {
    input_stream.readChar();
    input_stream.backup(1);
  } catch (java.io.IOException e1) {
    EOFSeen = true;
    error_after = lastReadPosition <= 1 ? "" : input_stream.GetImage();
    if (curChar == '\n' || curChar == '\r') {
       error_line++;
       error_column = 0;
    }
    else
       error_column++;
  }
  if (!EOFSeen) {
    input_stream.backup(1);
    error_after = lastReadPosition <= 1 ? "" : input_stream.GetImage();
  }
  throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column,
                          error_after, curChar, TokenMgrError.LEXICAL_ERROR);
}

private static final java.util.Map<Integer, int[]> startAndSize =
    new java.util.HashMap<Integer, int[]>();


private static final long[][] jjChars = new long[55][];
private static void InitNfaData() {
  for (int i = 0; i < 55; i++) {
    jjChars[i] = new long[1024];
    int ind = 0;
    // We originally generate something like RLE for the static arrays and
    // we actually expannd them here.
    for (int j = 0; j < jjCharData[i].length; j += 2) {
      for (int k = 0; k < (int)jjCharData[i][j]; k++) {
        jjChars[i][ind++] = jjCharData[i][j + 1];
      }
    }
  }
}
public static String[] lexStateNames = {
"DEFAULT"
, 
"IN_SINGLE_LINE_COMMENT"
, 
"IN_FORMAL_COMMENT"
, 
"IN_MULTI_LINE_COMMENT"
};
private static final int[] stringLiterals = {
1, 0, 9, 14, -1, 
1, 0, 10, 15, -1, 
1, 0, 12, 17, -1, 
1, 0, 13, 16, -1, 
1, 0, 32, 13, -1, 
2, 0, 33, 61, 105, -1, 
1, 0, 33, 98, -1, 
1, 0, 35, 126, -1, 
2, 0, 37, 61, 125, -1, 
1, 0, 37, 117, -1, 
2, 0, 38, 61, 122, -1, 
2, 0, 38, 38, 107, -1, 
1, 0, 38, 114, -1, 
1, 0, 40, 86, -1, 
2, 0, 42, 47, 22, -1, 
1, 0, 41, 87, -1, 
2, 0, 42, 47, 23, -1, 
2, 0, 42, 61, 120, -1, 
1, 0, 42, 112, -1, 
2, 0, 43, 61, 118, -1, 
2, 0, 43, 43, 108, -1, 
1, 0, 43, 110, -1, 
1, 0, 44, 93, -1, 
2, 0, 45, 61, 119, -1, 
2, 0, 45, 45, 109, -1, 
1, 0, 45, 111, -1, 
1, 0, 46, 94, 8, 
2, 0, 47, 61, 121, -1, 
2, 0, 47, 42, 20, 0, 
2, 0, 47, 47, 18, -1, 
1, 0, 47, 113, 2, 
1, 0, 58, 101, -1, 
1, 0, 59, 92, -1, 
2, 0, 60, 61, 103, -1, 
1, 0, 60, 97, -1, 
2, 0, 61, 61, 102, -1, 
1, 0, 61, 95, -1, 
2, 0, 62, 61, 104, -1, 
1, 0, 62, 96, -1, 
1, 0, 63, 100, -1, 
3, 0, 69, 79, 70, 12, 32, 
11, 0, 73, 71, 78, 79, 82, 69, 95, 67, 65, 83, 69, 3, 32, 
8, 0, 74, 65, 86, 65, 67, 79, 68, 69, 6, 32, 
9, 0, 76, 79, 79, 75, 65, 72, 69, 65, 68, 2, 32, 
4, 0, 77, 79, 82, 69, 9, 32, 
12, 0, 80, 65, 82, 83, 69, 82, 95, 66, 69, 71, 73, 78, 4, 32, 
10, 0, 80, 65, 82, 83, 69, 82, 95, 69, 78, 68, 5, 32, 
13, 0, 83, 80, 69, 67, 73, 65, 76, 95, 84, 79, 75, 69, 78, 8, 32, 
4, 0, 83, 75, 73, 80, 10, 32, 
15, 0, 84, 79, 75, 69, 78, 95, 77, 71, 82, 95, 68, 69, 67, 76, 83, 11, 32, 
5, 0, 84, 79, 75, 69, 78, 7, 32, 
1, 0, 91, 90, -1, 
1, 0, 93, 91, -1, 
2, 0, 94, 61, 124, -1, 
1, 0, 94, 116, -1, 
8, 0, 97, 98, 115, 116, 114, 97, 99, 116, 25, 32, 
7, 0, 98, 111, 111, 108, 101, 97, 110, 26, 32, 
5, 0, 98, 114, 101, 97, 107, 27, 32, 
4, 0, 98, 121, 116, 101, 28, 32, 
8, 0, 99, 111, 110, 116, 105, 110, 117, 101, 34, 32, 
5, 0, 99, 111, 110, 115, 116, 33, 32, 
5, 0, 99, 108, 97, 115, 115, 32, 32, 
5, 0, 99, 97, 116, 99, 104, 30, 32, 
4, 0, 99, 104, 97, 114, 31, 32, 
4, 0, 99, 97, 115, 101, 29, 32, 
7, 0, 100, 101, 102, 97, 117, 108, 116, 35, 32, 
6, 0, 100, 111, 117, 98, 108, 101, 37, 32, 
2, 0, 100, 111, 36, 32, 
7, 0, 101, 120, 116, 101, 110, 100, 115, 39, 32, 
4, 0, 101, 108, 115, 101, 38, 32, 
7, 0, 102, 105, 110, 97, 108, 108, 121, 42, 32, 
5, 0, 102, 108, 111, 97, 116, 43, 32, 
5, 0, 102, 105, 110, 97, 108, 41, 32, 
5, 0, 102, 97, 108, 115, 101, 40, 32, 
3, 0, 102, 111, 114, 44, 32, 
4, 0, 103, 111, 116, 111, 45, 32, 
10, 0, 105, 110, 115, 116, 97, 110, 99, 101, 111, 102, 49, 32, 
10, 0, 105, 109, 112, 108, 101, 109, 101, 110, 116, 115, 47, 32, 
9, 0, 105, 110, 116, 101, 114, 102, 97, 99, 101, 51, 32, 
6, 0, 105, 109, 112, 111, 114, 116, 48, 32, 
3, 0, 105, 110, 116, 50, 32, 
2, 0, 105, 102, 46, 32, 
4, 0, 108, 111, 110, 103, 52, 32, 
6, 0, 110, 97, 116, 105, 118, 101, 53, 32, 
4, 0, 110, 117, 108, 108, 55, 32, 
3, 0, 110, 101, 119, 54, 32, 
7, 0, 111, 112, 116, 105, 111, 110, 115, 1, 32, 
9, 0, 112, 114, 111, 116, 101, 99, 116, 101, 100, 58, 32, 
7, 0, 112, 114, 105, 118, 97, 116, 101, 57, 32, 
7, 0, 112, 97, 99, 107, 97, 103, 101, 56, 32, 
6, 0, 112, 117, 98, 108, 105, 99, 59, 32, 
6, 0, 114, 101, 116, 117, 114, 110, 60, 32, 
12, 0, 115, 121, 110, 99, 104, 114, 111, 110, 105, 122, 101, 100, 65, 32, 
6, 0, 115, 119, 105, 116, 99, 104, 64, 32, 
6, 0, 115, 116, 97, 116, 105, 99, 62, 32, 
5, 0, 115, 117, 112, 101, 114, 63, 32, 
5, 0, 115, 104, 111, 114, 116, 61, 32, 
9, 0, 116, 114, 97, 110, 115, 105, 101, 110, 116, 69, 32, 
6, 0, 116, 104, 114, 111, 119, 115, 68, 32, 
5, 0, 116, 104, 114, 111, 119, 67, 32, 
4, 0, 116, 114, 117, 101, 70, 32, 
4, 0, 116, 104, 105, 115, 66, 32, 
3, 0, 116, 114, 121, 71, 32, 
8, 0, 118, 111, 108, 97, 116, 105, 108, 101, 73, 32, 
4, 0, 118, 111, 105, 100, 72, 32, 
5, 0, 119, 104, 105, 108, 101, 74, 32, 
1, 0, 123, 88, -1, 
2, 0, 124, 61, 123, -1, 
2, 0, 124, 124, 106, -1, 
1, 0, 124, 115, -1, 
1, 0, 125, 89, -1, 
1, 0, 126, 99, -1};
static void InitStringLiteralData() {
startAndSize.put(9, new int[]{0, 1});
startAndSize.put(10, new int[]{5, 1});
startAndSize.put(12, new int[]{10, 1});
startAndSize.put(13, new int[]{15, 1});
startAndSize.put(32, new int[]{20, 1});
startAndSize.put(33, new int[]{25, 2});
startAndSize.put(35, new int[]{36, 1});
startAndSize.put(37, new int[]{41, 2});
startAndSize.put(38, new int[]{52, 3});
startAndSize.put(40, new int[]{69, 1});
startAndSize.put(131114, new int[]{74, 1});
startAndSize.put(41, new int[]{80, 1});
startAndSize.put(196650, new int[]{85, 1});
startAndSize.put(42, new int[]{91, 2});
startAndSize.put(43, new int[]{102, 3});
startAndSize.put(44, new int[]{119, 1});
startAndSize.put(45, new int[]{124, 3});
startAndSize.put(46, new int[]{141, 1});
startAndSize.put(47, new int[]{146, 4});
startAndSize.put(58, new int[]{169, 1});
startAndSize.put(59, new int[]{174, 1});
startAndSize.put(60, new int[]{179, 2});
startAndSize.put(61, new int[]{190, 2});
startAndSize.put(62, new int[]{201, 2});
startAndSize.put(63, new int[]{212, 1});
startAndSize.put(69, new int[]{217, 1});
startAndSize.put(73, new int[]{224, 1});
startAndSize.put(74, new int[]{239, 1});
startAndSize.put(76, new int[]{251, 1});
startAndSize.put(77, new int[]{264, 1});
startAndSize.put(80, new int[]{272, 2});
startAndSize.put(83, new int[]{302, 2});
startAndSize.put(84, new int[]{327, 2});
startAndSize.put(91, new int[]{355, 1});
startAndSize.put(93, new int[]{360, 1});
startAndSize.put(94, new int[]{365, 2});
startAndSize.put(97, new int[]{376, 1});
startAndSize.put(98, new int[]{388, 3});
startAndSize.put(99, new int[]{416, 6});
startAndSize.put(100, new int[]{471, 3});
startAndSize.put(101, new int[]{498, 2});
startAndSize.put(102, new int[]{517, 5});
startAndSize.put(103, new int[]{562, 1});
startAndSize.put(105, new int[]{570, 6});
startAndSize.put(108, new int[]{634, 1});
startAndSize.put(110, new int[]{642, 3});
startAndSize.put(111, new int[]{667, 1});
startAndSize.put(112, new int[]{678, 4});
startAndSize.put(114, new int[]{723, 1});
startAndSize.put(115, new int[]{733, 5});
startAndSize.put(116, new int[]{787, 6});
startAndSize.put(118, new int[]{842, 2});
startAndSize.put(119, new int[]{862, 1});
startAndSize.put(123, new int[]{871, 1});
startAndSize.put(124, new int[]{876, 3});
startAndSize.put(125, new int[]{893, 1});
startAndSize.put(126, new int[]{898, 1});
}
private static final long[][] jjCharData = {
new long[] {1, 4398046511104L},
new long[] {1, -140737488355329L, 1023, -1L},
new long[] {1, 4398046511104L},
new long[] {1, 140737488355328L},
new long[] {1, 287667426198290432L},
new long[] {1, 287948901175001088L},
new long[] {1, 0L, 1, 17592186048512L},
new long[] {1, 70368744177664L},
new long[] {1, 287948901175001088L},
new long[] {1, 0L, 1, 137438953504L},
new long[] {1, 43980465111040L},
new long[] {1, 287948901175001088L},
new long[] {1, 0L, 1, 343597383760L},
new long[] {1, 549755813888L},
new long[] {1, -549755823105L, 1, -268435457L, 1022, -1L},
new long[] {1, 549755813888L},
new long[] {1, 0L, 1, 268435456L},
new long[] {1, 566935683072L, 1, 5700160604602368L},
new long[] {1, 71776119061217280L},
new long[] {1, 71776119061217280L},
new long[] {1, 4222124650659840L},
new long[] {1, 71776119061217280L},
new long[] {1, 17179869184L},
new long[] {1, -17179878401L, 1, -268435457L, 1022, -1L},
new long[] {1, 0L, 1, 268435456L},
new long[] {1, 566935683072L, 1, 5700160604602368L},
new long[] {1, 17179869184L},
new long[] {1, 71776119061217280L},
new long[] {1, 71776119061217280L},
new long[] {1, 4222124650659840L},
new long[] {1, 71776119061217280L},
new long[] {1, 68719476736L, 1, 576460745995190270L, 1, 0L, 1, -36028797027352577L, 124, -1L, 65, 0L, 5, -1L, 1, 65535L, 5, 0L, 2, -1L, 2, 0L, 36, -1L, 1, 70368744177663L, 67, 0L, 328, -1L, 356, 0L, 8, -1L},
new long[] {1, 287948969894477824L, 1, 576460745995190270L, 1, 0L, 1, -36028797027352577L, 124, -1L, 65, 0L, 5, -1L, 1, 65535L, 5, 0L, 2, -1L, 2, 0L, 36, -1L, 1, 70368744177663L, 67, 0L, 328, -1L, 356, 0L, 8, -1L},
new long[] {1, 287948901175001088L},
new long[] {1, 287948901175001088L},
new long[] {1, 70368744177664L},
new long[] {1, 287948901175001088L},
new long[] {1, 0L, 1, 137438953504L},
new long[] {1, 43980465111040L},
new long[] {1, 287948901175001088L},
new long[] {1, 287948901175001088L},
new long[] {1, 0L, 1, 137438953504L},
new long[] {1, 43980465111040L},
new long[] {1, 287948901175001088L},
new long[] {1, 287948901175001088L},
new long[] {1, 0L, 1, 137438953504L},
new long[] {1, 43980465111040L},
new long[] {1, 287948901175001088L},
new long[] {1, 281474976710656L},
new long[] {1, 0L, 1, 72057594054705152L},
new long[] {1, 287948901175001088L, 1, 541165879422L},
new long[] {1, 71776119061217280L},
new long[] {1, 9216L},
new long[] {1, 1024L},
new long[] {1, 8192L}};
private static final int[][] jjcompositeState = {
new int[]{}, 
new int[]{}, 
new int[]{}, 
new int[]{3, 4, 7, 13, 22, 31, 33, 48}, 
new int[]{}, 
new int[]{}, 
new int[]{}, 
new int[]{}, 
new int[]{}, 
new int[]{}, 
new int[]{}, 
new int[]{}, 
new int[]{}, 
new int[]{}, 
new int[]{}, 
new int[]{}, 
new int[]{}, 
new int[]{}, 
new int[]{}, 
new int[]{}, 
new int[]{}, 
new int[]{}, 
new int[]{}, 
new int[]{}, 
new int[]{}, 
new int[]{}, 
new int[]{}, 
new int[]{}, 
new int[]{}, 
new int[]{}, 
new int[]{}, 
new int[]{}, 
new int[]{}, 
new int[]{}, 
new int[]{}, 
new int[]{}, 
new int[]{}, 
new int[]{}, 
new int[]{}, 
new int[]{}, 
new int[]{}, 
new int[]{}, 
new int[]{}, 
new int[]{}, 
new int[]{}, 
new int[]{}, 
new int[]{}, 
new int[]{}, 
new int[]{}, 
new int[]{}, 
new int[]{}, 
new int[]{}, 
new int[]{52, 54}, 
new int[]{}, 
new int[]{}};
private static final int[] jjmatchKinds = {
2147483647, 
19, 
2147483647, 
2147483647, 
75, 
75, 
75, 
2147483647, 
79, 
2147483647, 
2147483647, 
79, 
79, 
2147483647, 
2147483647, 
81, 
2147483647, 
2147483647, 
2147483647, 
2147483647, 
2147483647, 
2147483647, 
2147483647, 
2147483647, 
2147483647, 
2147483647, 
82, 
2147483647, 
2147483647, 
2147483647, 
2147483647, 
83, 
83, 
2147483647, 
2147483647, 
79, 
79, 
2147483647, 
2147483647, 
79, 
2147483647, 
2147483647, 
2147483647, 
79, 
2147483647, 
2147483647, 
2147483647, 
2147483647, 
75, 
2147483647, 
75, 
75, 
21, 
21, 
2147483647};
private static final int[][] jjnextStateSet = {
new int[]{1}, 
new int[]{}, 
new int[]{0}, 
new int[]{2}, 
new int[]{5, 6}, 
new int[]{5, 6}, 
new int[]{}, 
new int[]{8}, 
new int[]{8, 9, 12}, 
new int[]{10, 11}, 
new int[]{11}, 
new int[]{11, 12}, 
new int[]{}, 
new int[]{14, 16}, 
new int[]{15}, 
new int[]{}, 
new int[]{17, 18, 20}, 
new int[]{15}, 
new int[]{15, 19}, 
new int[]{15}, 
new int[]{21}, 
new int[]{19}, 
new int[]{23, 24, 26}, 
new int[]{23, 24, 26}, 
new int[]{25, 27, 29}, 
new int[]{23, 24, 26}, 
new int[]{}, 
new int[]{23, 24, 26, 28}, 
new int[]{23, 24, 26}, 
new int[]{30}, 
new int[]{28}, 
new int[]{32}, 
new int[]{32}, 
new int[]{12, 34, 35, 40, 41, 44, 45}, 
new int[]{34, 35}, 
new int[]{12, 36, 37}, 
new int[]{12, 36, 37}, 
new int[]{38, 39}, 
new int[]{39}, 
new int[]{12, 39}, 
new int[]{40, 41}, 
new int[]{42, 43}, 
new int[]{43}, 
new int[]{12, 43}, 
new int[]{12, 44, 45}, 
new int[]{46, 47}, 
new int[]{47}, 
new int[]{12, 47}, 
new int[]{6, 49, 51}, 
new int[]{50}, 
new int[]{6, 50}, 
new int[]{6, 51}, 
new int[]{}, 
new int[]{}, 
new int[]{53}};
private static final int[] jjInitStates  = {
3, 52, -1, -1};
private static final int[] canMatchAnyChar = {
2147483647, 24, 24, 24};
public static final String[] jjstrLiteralImages = {
null
, 
"\157\160\164\151\157\156\163", 
"\114\117\117\113\101\110\105\101\104", 
"\111\107\116\117\122\105\137\103\101\123\105", 
"\120\101\122\123\105\122\137\102\105\107\111\116", 
"\120\101\122\123\105\122\137\105\116\104", 
"\112\101\126\101\103\117\104\105", 
"\124\117\113\105\116", 
"\123\120\105\103\111\101\114\137\124\117\113\105\116", 
"\115\117\122\105", 
"\123\113\111\120", 
"\124\117\113\105\116\137\115\107\122\137\104\105\103\114\123", 
"\105\117\106", 
"\40", 
"\11", 
"\12", 
"\15", 
"\14", 
"\57\57", 
null
, 
"\57\52", 
null
, 
"\52\57", 
"\52\57", 
null
, 
"\141\142\163\164\162\141\143\164", 
"\142\157\157\154\145\141\156", 
"\142\162\145\141\153", 
"\142\171\164\145", 
"\143\141\163\145", 
"\143\141\164\143\150", 
"\143\150\141\162", 
"\143\154\141\163\163", 
"\143\157\156\163\164", 
"\143\157\156\164\151\156\165\145", 
"\144\145\146\141\165\154\164", 
"\144\157", 
"\144\157\165\142\154\145", 
"\145\154\163\145", 
"\145\170\164\145\156\144\163", 
"\146\141\154\163\145", 
"\146\151\156\141\154", 
"\146\151\156\141\154\154\171", 
"\146\154\157\141\164", 
"\146\157\162", 
"\147\157\164\157", 
"\151\146", 
"\151\155\160\154\145\155\145\156\164\163", 
"\151\155\160\157\162\164", 
"\151\156\163\164\141\156\143\145\157\146", 
"\151\156\164", 
"\151\156\164\145\162\146\141\143\145", 
"\154\157\156\147", 
"\156\141\164\151\166\145", 
"\156\145\167", 
"\156\165\154\154", 
"\160\141\143\153\141\147\145", 
"\160\162\151\166\141\164\145", 
"\160\162\157\164\145\143\164\145\144", 
"\160\165\142\154\151\143", 
"\162\145\164\165\162\156", 
"\163\150\157\162\164", 
"\163\164\141\164\151\143", 
"\163\165\160\145\162", 
"\163\167\151\164\143\150", 
"\163\171\156\143\150\162\157\156\151\172\145\144", 
"\164\150\151\163", 
"\164\150\162\157\167", 
"\164\150\162\157\167\163", 
"\164\162\141\156\163\151\145\156\164", 
"\164\162\165\145", 
"\164\162\171", 
"\166\157\151\144", 
"\166\157\154\141\164\151\154\145", 
"\167\150\151\154\145", 
null
, 
null
, 
null
, 
null
, 
null
, 
null
, 
null
, 
null
, 
null
, 
null
, 
null
, 
"\50", 
"\51", 
"\173", 
"\175", 
"\133", 
"\135", 
"\73", 
"\54", 
"\56", 
"\75", 
"\76", 
"\74", 
"\41", 
"\176", 
"\77", 
"\72", 
"\75\75", 
"\74\75", 
"\76\75", 
"\41\75", 
"\174\174", 
"\46\46", 
"\53\53", 
"\55\55", 
"\53", 
"\55", 
"\52", 
"\57", 
"\46", 
"\174", 
"\136", 
"\45", 
"\53\75", 
"\55\75", 
"\52\75", 
"\57\75", 
"\46\75", 
"\174\75", 
"\136\75", 
"\45\75", 
"\43"};
private static final long[] jjtoSkip = {
253952L, 0L, 1L};
private static final long[] jjtoSpecial = {
14680064L, 0L, 1L};
private static final long[] jjtoMore = {
18612224L, 0L, 1L};
private static final long[] jjtoToken = {
-33546241L, 9223372036854775807L, 1L};
private static final int[] jjnewLexState = {
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 3, 0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};
static void TokenLexicalActions(Token matchedToken) {
  switch(matchedToken.kind) {
    default: break;
  }
}
static void SkipLexicalActions(Token matchedToken) {
  switch(jjmatchedKind) {
    default: break;
  }
  switch(jjmatchedKind) {
    default: break;
  }
}
static void MoreLexicalActions() {
jjimageLen += (lengthOfMatch = jjmatchedPos + 1);
  switch(jjmatchedKind) {
    case 19: {

      input_stream.backup(1);
      break;
    }
    default: break;
  }
}
static {
  InitStringLiteralData();
  InitNfaData(); } 
}
/* JavaCC - OriginalChecksum=118ff454e7dfe31a11759952cb75ea9d (do not edit this line) */
